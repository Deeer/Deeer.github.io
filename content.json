{"meta":{"title":"🦖 Deeer 👨‍💻","subtitle":"士不可以不弘毅，任重而道远。","description":"代码手工艺人 | Love Linux  | 追求体验","author":"Deeer","url":"http://deeer.github.io","root":"/"},"pages":[{"title":"about","date":"2015-07-26T08:45:00.000Z","updated":"2020-09-19T12:06:43.885Z","comments":true,"path":"about/index.html","permalink":"http://deeer.github.io/about/index.html","excerpt":"","text":"HEY , THIS IS DEEER."},{"title":"tags","date":"2015-06-02T16:09:09.000Z","updated":"2015-06-06T17:47:06.000Z","comments":true,"path":"tags/index.html","permalink":"http://deeer.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2015-07-26T09:11:08.000Z","updated":"2018-02-27T14:59:45.000Z","comments":true,"path":"categories/index.html","permalink":"http://deeer.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解GCD","slug":"深入理解GCD","date":"2021-03-29T15:06:14.000Z","updated":"2021-03-29T16:27:34.858Z","comments":true,"path":"2021/03/29/深入理解GCD/","link":"","permalink":"http://deeer.github.io/2021/03/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GCD/","excerpt":"","text":"队列在GCD中包含了四种队列 ： 主队列、 全局队列、 管理队列、自定义队列 自定义队列队列底层使用dispatch_queue_create进行创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161dispatch_queue_tdispatch_queue_create(const char *label, dispatch_queue_attr_t attr)&#123; return _dispatch_lane_create_with_target(label, attr, DISPATCH_TARGET_QUEUE_DEFAULT, true);&#125;----------------------------------------// dispatch_queue_t tq 目标队列，队列中实际的任务在target queue 中执行，这里默认传 DISPATCH_TARGET_QUEUE_DEFAULT - NULL// dispatch_queue_attr_t 队列属性 // 从参数中获取qos属性DISPATCH_NOINLINEstatic dispatch_queue_t_dispatch_lane_create_with_target(const char *label, dispatch_queue_attr_t dqa, dispatch_queue_t tq, bool legacy)&#123; // 获取队列属性信息 // dispatch_queue_attr_info_s // typedef struct dispatch_queue_attr_info_s &#123; // dispatch_qos_t dqai_qos : 8; // int dqai_relpri : 8; // uint16_t dqai_overcommit:2; // uint16_t dqai_autorelease_frequency:2; // uint16_t dqai_concurrent:1; // uint16_t dqai_inactive:1; // &#125; dispatch_queue_attr_info_t; dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa); // // Step 1: Normalize arguments (qos, overcommit, tq) // // 获取队列的qos信息 dispatch_qos_t qos = dqai.dqai_qos; //#if !HAVE_PTHREAD_WORKQUEUE_QOS if (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123; dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED; &#125; if (qos == DISPATCH_QOS_MAINTENANCE) &#123; dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND; &#125;#endif // !HAVE_PTHREAD_WORKQUEUE_QOS // overcommit信息 _dispatch_queue_attr_overcommit_t overcommit = dqai.dqai_overcommit; // 如果没有overcommit信息 且 有 targetqueue if (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123; // 不能同时指定 overcommit 信息 和 非全局targetqueue if (tq-&gt;do_targetq) &#123; DISPATCH_CLIENT_CRASH(tq, &quot;Cannot specify both overcommit and &quot; &quot;a non-global target queue&quot;); &#125; &#125; if (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123; // Handle discrepancies between attr and target queue, attributes win if (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123; if (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123; overcommit = _dispatch_queue_attr_overcommit_enabled; &#125; else &#123; overcommit = _dispatch_queue_attr_overcommit_disabled; &#125; &#125; if (qos == DISPATCH_QOS_UNSPECIFIED) &#123; qos = _dispatch_priority_qos(tq-&gt;dq_priority); &#125; tq = NULL; &#125; else if (tq &amp;&amp; !tq-&gt;do_targetq) &#123; // target 是 pthread 或者runloop的root queue ，设置QOS 或者 overcommit 是不允许的 // target is a pthread or runloop root queue, setting QoS or overcommit // is disallowed if (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123; DISPATCH_CLIENT_CRASH(tq, &quot;Cannot specify an overcommit attribute &quot; &quot;and use this kind of target queue&quot;); &#125; &#125; else &#123; if (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123; // Serial queues default to overcommit! // 串行队列的overcommit 是 启用的 overcommit = dqai.dqai_concurrent ? _dispatch_queue_attr_overcommit_disabled : _dispatch_queue_attr_overcommit_enabled; &#125; &#125; // 如果没有target queue， 设置获取从root queue 中去获取 if (!tq) &#123; // 获取root queue tq = _dispatch_get_root_queue( qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; if (unlikely(!tq)) &#123; DISPATCH_CLIENT_CRASH(qos, &quot;Invalid queue attribute&quot;); &#125; &#125; // // Step 2: Initialize the queue // if (legacy) &#123; // if any of these attributes is specified, use non legacy classes if (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123; legacy = false; &#125; &#125; const void *vtable; dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : 0; // if (dqai.dqai_concurrent) &#123; vtable = DISPATCH_VTABLE(queue_concurrent); &#125; else &#123; vtable = DISPATCH_VTABLE(queue_serial); &#125; // auto relase switch (dqai.dqai_autorelease_frequency) &#123; case DISPATCH_AUTORELEASE_FREQUENCY_NEVER: dqf |= DQF_AUTORELEASE_NEVER; break; case DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM: dqf |= DQF_AUTORELEASE_ALWAYS; break; &#125; if (label) &#123; const char *tmp = _dispatch_strdup_if_mutable(label); if (tmp != label) &#123; dqf |= DQF_LABEL_NEEDS_FREE; label = tmp; &#125; &#125; dispatch_lane_t dq = _dispatch_object_alloc(vtable, sizeof(struct dispatch_lane_s)); _dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ? DISPATCH_QUEUE_WIDTH_MAX : 1, DISPATCH_QUEUE_ROLE_INNER | (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : 0)); dq-&gt;dq_label = label; dq-&gt;dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos, dqai.dqai_relpri); if (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123; dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT; &#125; if (!dqai.dqai_inactive) &#123; // 从target 继承优先级 _dispatch_queue_priority_inherit_from_target(dq, tq); _dispatch_lane_inherit_wlh_from_target(dq, tq); &#125; _dispatch_retain(tq); dq-&gt;do_targetq = tq; _dispatch_object_debug(dq, &quot;%s&quot;, __func__); return _dispatch_trace_queue_create(dq)._dq;&#125; 全局队列 - dispatch_get_global_queue1234567891011121314151617181920212223dispatch_queue_global_tdispatch_get_global_queue(long priority, unsigned long flags)&#123; dispatch_assert(countof(_dispatch_root_queues) == DISPATCH_ROOT_QUEUE_COUNT); if (flags &amp; ~(unsigned long)DISPATCH_QUEUE_OVERCOMMIT) &#123; return DISPATCH_BAD_INPUT; &#125; dispatch_qos_t qos = _dispatch_qos_from_queue_priority(priority);#if !HAVE_PTHREAD_WORKQUEUE_QOS if (qos == QOS_CLASS_MAINTENANCE) &#123; qos = DISPATCH_QOS_BACKGROUND; &#125; else if (qos == QOS_CLASS_USER_INTERACTIVE) &#123; qos = DISPATCH_QOS_USER_INITIATED; &#125;#endif if (qos == DISPATCH_QOS_UNSPECIFIED) &#123; return DISPATCH_BAD_INPUT; &#125; return _dispatch_get_root_queue(qos, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);&#125; 这里我们可以看到全局队列最终调用的是_dispatch_get_root_queue 123456789DISPATCH_ALWAYS_INLINE DISPATCH_CONSTstatic inline dispatch_queue_global_t_dispatch_get_root_queue(dispatch_qos_t qos, bool overcommit)&#123; if (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123; DISPATCH_CLIENT_CRASH(qos, &quot;Corrupted priority&quot;); &#125; return &amp;_dispatch_root_queues[2 * (qos - 1) + overcommit];&#125; 实际上_dispatch_root_queuess是一个系统硬编码的队列数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct dispatch_queue_global_s _dispatch_root_queues[] = &#123;#define _DISPATCH_ROOT_QUEUE_IDX(n, flags) \\ ((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \\ DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \\ DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)#define _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \\ [_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \\ DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), \\ .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \\ .do_ctxt = _dispatch_root_queue_ctxt(_DISPATCH_ROOT_QUEUE_IDX(n, flags)), \\ .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \\ .dq_priority = flags | ((flags &amp; DISPATCH_PRIORITY_FLAG_FALLBACK) ? \\ _dispatch_priority_make_fallback(DISPATCH_QOS_##n) : \\ _dispatch_priority_make(DISPATCH_QOS_##n, 0)), \\ __VA_ARGS__ \\ &#125; _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, 0, .dq_label = &quot;com.apple.root.maintenance-qos&quot;, .dq_serialnum = 4, ), _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.maintenance-qos.overcommit&quot;, .dq_serialnum = 5, ), _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, 0, .dq_label = &quot;com.apple.root.background-qos&quot;, .dq_serialnum = 6, ), _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.background-qos.overcommit&quot;, .dq_serialnum = 7, ), _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, 0, .dq_label = &quot;com.apple.root.utility-qos&quot;, .dq_serialnum = 8, ), _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.utility-qos.overcommit&quot;, .dq_serialnum = 9, ), _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK, .dq_label = &quot;com.apple.root.default-qos&quot;, .dq_serialnum = 10, ), _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.default-qos.overcommit&quot;, .dq_serialnum = 11, ), _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, 0, .dq_label = &quot;com.apple.root.user-initiated-qos&quot;, .dq_serialnum = 12, ), _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.user-initiated-qos.overcommit&quot;, .dq_serialnum = 13, ), _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, 0, .dq_label = &quot;com.apple.root.user-interactive-qos&quot;, .dq_serialnum = 14, ), _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT, .dq_label = &quot;com.apple.root.user-interactive-qos.overcommit&quot;, .dq_serialnum = 15, ),&#125;; 主队列1234567891011struct dispatch_queue_static_s _dispatch_main_q = &#123; DISPATCH_GLOBAL_OBJECT_HEADER(queue_main),#if !DISPATCH_USE_RESOLVERS .do_targetq = _dispatch_get_default_queue(true),#endif .dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(1) | DISPATCH_QUEUE_ROLE_BASE_ANON, .dq_label = &quot;com.apple.main-thread&quot;, .dq_atomic_flags = DQF_THREAD_BOUND | DQF_WIDTH(1), .dq_serialnum = 1,&#125;; 管理队列1234567891011121314151617181920212223242526struct dispatch_queue_global_s _dispatch_mgr_root_queue = &#123; DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, .do_ctxt = &amp;_dispatch_mgr_root_queue_pthread_context, .dq_label = &quot;com.apple.root.libdispatch-manager&quot;, .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), .dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER | DISPATCH_PRIORITY_SATURATED_OVERRIDE, .dq_serialnum = 3, .dgq_thread_pool_size = 1,&#125;;struct dispatch_queue_static_s _dispatch_mgr_q = &#123; DISPATCH_GLOBAL_OBJECT_HEADER(queue_mgr), .dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(1) | DISPATCH_QUEUE_ROLE_BASE_ANON, .do_ctxt = (void *)-1, .do_targetq = _dispatch_mgr_root_queue._as_dq, .dq_label = &quot;com.apple.libdispatch-manager&quot;, .dq_atomic_flags = DQF_WIDTH(1), .dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER | DISPATCH_PRIORITY_SATURATED_OVERRIDE, .dq_serialnum = 2,&#125;; 可以看到，无论是**主队列**，**管理队列**，还是**自定义队列**，都使用root queue作为target queue Target QueueDarget queue 是队列任务最终执行的地方。但是全局队列没有设置target queue (do_targetq) QOS在设置队列优先级的时候会涉及到QOS的设置。QOS是自iOS8后新引入的特性。主要包含以下五种： NSQualityOfServiceUserInteractive用户交互相关，通常和UI相关。 NSQualityOfServiceUserInitiated由用户发起且需要立即完成的任务 NSQualityOfServiceUtility需要花费一些时间，不是马上需要结果的任务 NSQualityOfServiceBackground后台任务 NSQualityOfServiceDefault默认优先级，介于NSQualityOfServiceUserInteractive 和 NSQualityOfServiceUtility 之间，在没有QOS信息时默认使用队列优先级和QOS类之间的映射关系如下 1234DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATEDDISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITYDISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND","categories":[],"tags":[]}],"categories":[],"tags":[]}