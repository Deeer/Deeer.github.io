<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="代码手工艺人 | Love Linux  | 追求体验" />



  <meta name="keywords" content="weak," />



  <link rel="alternate" href="/atom.xml" title="Dee+'s Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      baidu: '',
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> weak源码分析 // Dee+'s Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Dee+'s Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          关于
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              weak源码分析
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2018-11-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/ScourceCode/">ScourceCode</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h1 id="Weak源码分析"><a href="#Weak源码分析" class="headerlink" title="Weak源码分析"></a>Weak源码分析</h1><p>为了后期解释起来更为流畅，我们先看一些相关的概念，方便后期解读源码时能<br>无缝对接</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="SideTables"><a href="#SideTables" class="headerlink" title="SideTables"></a>SideTables</h3><p><code>SideTabels</code>是一个<code>64</code>位长度的<code>hash</code>数组.<br>我们来看下具体的实现方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>SideTables</code>本质上<code>StripedMap</code>类型。其中包含的元素为SideTable类型</p>
<p>这里的<code>reinterpret_cast</code>关键字，我们可以理解为强制类型转换，也就是将<code>SideTableBuf</code>转换为<br><code>StripedMap</code>类型，其中包含的元素为<code>SideTale</code>类型。<br>我们进一步查看<code>StriedMap</code>的结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">emplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_EMBEDDED</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT <span class="built_in">array</span>[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将p的值以二进制的方式解释为uintptr_t（unsigned long）并赋值给addr</span></span><br><span class="line">        <span class="comment">// 保证具有相同的比特位</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="comment">// addr / 2^4           addr / 2^9</span></span><br><span class="line">        <span class="comment">// % StripeCount 保证index不会越界</span></span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁操作放在了类模版中</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载操作符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcuts for StripedMaps of locks.</span></span><br><span class="line">    <span class="comment">// 锁操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i].value.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlockAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i].value.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forceResetAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i].value.forceReset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defineLockOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            lockdebug_lock_precedes_lock(&amp;<span class="built_in">array</span>[i<span class="number">-1</span>].value, &amp;<span class="built_in">array</span>[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">precedeLock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *newlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        lockdebug_lock_precedes_lock(&amp;<span class="built_in">array</span>[StripeCount<span class="number">-1</span>].value, newlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">succeedLock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *oldlock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assumes defineLockOrder is also called</span></span><br><span class="line">        lockdebug_lock_precedes_lock(oldlock, &amp;<span class="built_in">array</span>[<span class="number">0</span>].value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">void</span> *<span class="title">getLock</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; StripeCount) <span class="keyword">return</span> &amp;<span class="built_in">array</span>[i].value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    StripedMap() &#123;</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> base = (<span class="keyword">uintptr_t</span>)&amp;<span class="built_in">array</span>[<span class="number">0</span>].value;</span><br><span class="line">        <span class="keyword">uintptr_t</span> delta = (<span class="keyword">uintptr_t</span>)&amp;<span class="built_in">array</span>[<span class="number">1</span>].value - base;</span><br><span class="line">        assert(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        assert(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<ul>
<li><strong>PaddedT</strong></li>
</ul>
<p>可以看到这个<code>StripedMap</code>是一<code>class</code>类型的数据结构，其中声明了一个<code>PaddedT</code>类型的<code>64</code>个长度的<code>array</code>成员变量<br>而<code>PaddedT</code>是一个结构体类型，其中包含一个泛型值<code>value</code>，并且长度<code>64</code>位</p>
<ul>
<li>indexForPointer</li>
</ul>
<p>这个类中还包含一个<code>indexForPointer</code>方法，实现中我们看到主要还是调用了<code>reinterpret_cast</code>将传入的对象地址<br>进行类型转换的，并通过一定算法计算出指针的<code>index</code>，最后的<code>%StripeCount</code>保证保证了<code>index</code>不会越界</p>
<ul>
<li><strong>操作符重载</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们结合源码中的用法进行进一步讲解</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SideTable&amp; <span class="keyword">table</span> = SideTables()[this];</span><br></pre></td></tr></table></figure>
<p>代码中将一个对象传入，由于重载了运算符所以实际的<code>[this]</code>会进入的到这个类中的重载方法<code>array[indexForPointer(p)]</code>里。<br>然后通过<code>indexForPointer</code>方法得到的进行强制类型转换，最终得到这个这个<code>hash</code>地址在<code>array</code>中的<code>index</code>。通过<code>index</code>得到的是<br>这个<code>hash</code>表中的键值对，最后调用获取<code>value</code>方法得到相应的<code>SideTable</code>（注意这里不是<code>SideTables</code>）</p>
<hr>
<p>到这里为止，我们了解了<code>SideTables</code>的创建的和<code>SideTable</code>的获取。<br>初步了解到，寻找<code>SideTable</code>的主要是通过对对象的地址的强制类型转换，并通过一定算法得到<code>SideTables</code>中对应<code>index</code>的键值对，到这里为止，<strong>实际的结构并不像网上流传的那样，是用地址的<code>hash</code>作为<code>key</code>的，而是通过数字。**</strong>只是这里的位操作的含义，还有待考究**<br>当然，我们可以将这一个步骤简单的理解为一种<code>hash</code>算法，通过传入对象的地址，找到了对应的<code>index</code></p>
<ul>
<li><strong>锁操作</strong></li>
</ul>
<p>在<code>StripedMap</code>类实现的源码中还包含了对锁操作的各种便捷方法。相关内容，后续我们会讲到</p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><p>这里我们直接贴出源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="comment">// 锁的定义放在了实际的类型中</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">    </span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        <span class="comment">// memset 用来对一段内存空间全部设置为某个字符</span></span><br><span class="line">        <span class="comment">// 一般用在定义的字符进行初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; slock.lock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; slock.unlock(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forceReset</span><span class="params">()</span> </span>&#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中的变量我们一一来分析</p>
<ul>
<li><strong>自旋锁 <code>spinlock_t</code></strong></li>
</ul>
<p>自旋锁在<code>runtime</code>源码中经常看到，当自旋锁被一个线程获得时，他不能被其他线程获得。和互斥锁不同的是，它不会从函数直接返回，让线程<code>sleep</code>，而是让其处于<code>active</code>状态。<br>由于自旋不释放<code>CPU</code>，因而持有自选锁的线程应尽快释放锁,好的一面的看，这样减少了上下文的切换速度。也因此它的使用场景应该是那种占用时间较短抢占情况。</p>
<p>我们注意到这里 <code>slock</code> 属性是放置每个<code>SideTable</code>下的，这种细粒度的锁到底有什么意义？<br>我们知道，一般代码加锁是为了保障读写安全，结合实际，如果整个<code>SideTables</code>只用一个锁去做处理，也就意味着，一旦表中的一个<code>SideTable</code>在被其他线程操作，那么其他线程将无法对其他<code>SideTable</code>进行处理，可想而知这种实现方式的效率是比较低的。而如果我们转换思想，降低锁的粒度，让他分配到每个<code>SideTable</code>中时，即使表中有<code>SideTable</code>正在被读取或者写入，但是不会影响到表中其他的元素。同时也保证了线程读写安全。在一定程度上给数据读写提供提供了相当高的伸缩性，每个锁的在理想情况下共同分担竞争请求。<br>这种处理方式也就是所谓拆分锁。</p>
<ul>
<li><strong>RefcountMap</strong> </li>
</ul>
<p>底层方法中看到这样一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_setWeaklyReferenced_nolock()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 在sidetables中找到对应的表</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 修改引用数量</span></span><br><span class="line">    <span class="comment">// |= 两边的值做或运算</span></span><br><span class="line">    <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED = 1</span></span><br><span class="line">    <span class="comment">// 也就是每次都+1， 但他的计数是基于比特位操作的</span></span><br><span class="line">    table.refcnts[<span class="keyword">this</span>] |= SIDE_TABLE_WEAKLY_REFERENCED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，底层实现中，通过<code>this</code>指针找到了<code>SideTables</code>中的<code>SideTable</code>,然后通过这个表中的<code>refcnts</code>成员变量，它是全局<br>的一个引用计数<code>hash</code>表，在<code>Sidetable</code>中，<code>refcnts</code>管理引用计数，<code>weak_table</code>用于管理指向对象的一个<code>or</code>一批指针。<br>由此可以看出，<code>SideTable</code>管理这个引用计数，又使用<code>weak_table_t</code>类型的哈希表保存了这些引用。</p>
<p>从调用方式中，我们能了解到，<code>RefcountMap refcnts</code>实质上是一个以对象地址为<code>key</code>，计数值为<code>value</code>的<code>hash</code>表。</p>
<ul>
<li><p><strong>weak_table_t</strong> </p>
<p>全局的弱引用表，将对象的地址作为<code>key</code>值，<code>weak_entry_t</code> 作为<code>value</code>值<br>具体结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="keyword">size_t</span>  num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>weak_entries</code> 是一个存放弱引用的数组</p>
<p>其中包含一个 <code>weak_entry_t</code> 类型的变量，它的实例结构是这样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">truct <span class="keyword">weak_entry_t</span> &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwzu8tztx8j30q40dzta0.jpg" alt=""></p>
<p>注意到这里采用<code>union</code>包含了两种类型的数据结构。当弱引用数量小于<code>WEAK_INLINE_COUNT</code>的时候，使用定长的<code>inline_referrers</code>数组进行存储<br>而当大于这个数量的时候，原先的数据会转移到第一种存储结构中，这个类型的数组会随着自身存储数据量的改变动态调整容器自身大小。<br>在这个结构体中还有个<code>out_of_line</code>方法来判断是否使用了动态数组。对于<code>REFERRERS_OUT_OF_LINE</code>这个宏定义的注释说明是这样写的</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// out_of_line_ness field overlaps with the low two bits of inline_referrers[<span class="number">1</span>].</span><br><span class="line">// inline_referrers[<span class="number">1</span>] <span class="built_in">is</span> a DisguisedPtr of a pointer-aligned address.</span><br><span class="line">// The low two bits of a pointer-aligned DisguisedPtr will always be <span class="number">0b00</span></span><br><span class="line">// (disguised nil <span class="keyword">or</span> <span class="number">0x80</span>..<span class="number">00</span>) <span class="keyword">or</span> <span class="number">0b11</span> (any other address).</span><br><span class="line">// Therefore out_of_line_ness == <span class="number">0b10</span> <span class="built_in">is</span> used to mark the out-of-line state.</span><br><span class="line">#<span class="built_in">define</span> REFERRERS_OUT_OF_LINE <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从中我们得到以下几点信息</p>
<ol>
<li><code>out_of_line_ness</code> 字段是<code>inline_referrers[1]</code>中重叠的最低两位</li>
<li><code>inline_referrers[1]</code>是一个<code>DisguisedPtr</code>类型的对齐指针地址</li>
<li><code>DisguisedPtr</code>类型的对齐指针地址的最低位总是<code>0b00</code>（<code>nil</code> 或者 <code>0x80..00</code>） 或者 <code>0b11</code>(任何其他地址)</li>
</ol>
<p>因为<code>2</code>的的二进制可以表示的<code>0b10</code>,这里用这个作为标志位，在插入第五个弱引用指针的时候，修改这里的标志位。</p>
<p>具体代码如下</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (! entry-&gt;</span>out_of_line())</span><br><span class="line">    &#123;   <span class="comment">// 0-3</span></span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// 尝试插入inline数组中</span></span><br><span class="line">        <span class="comment">// 注意这里没有等于，也就是意味着，数量达到WEAK_INLINE_COUNT时，就会触发下面的动态数组</span></span><br><span class="line">        <span class="comment">// 遍历数组，</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当添加第4个的时候，out_of_line还是为No</span></span><br><span class="line">        <span class="comment">// 从第5个开始执行下面的代码</span></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="comment">// 在无法插入的情况下，开发分配outline动态数组</span></span><br><span class="line">        <span class="comment">// 创建数组</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="comment">// 复制inline_referrers 中的数组</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组赋值</span></span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line">        <span class="comment">// 数组数量复制</span></span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        <span class="comment">// 在这里修改了标志位</span></span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">assert</span>(entry-&gt;</span>out_of_line());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态扩容</span></span><br><span class="line">    <span class="comment">// 第5个这里才执行插入</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新hash</span></span><br><span class="line">    <span class="function"><span class="title">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">    </span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，只有当<code>inline_referrers</code>数组被填满的时候，也就是当添加第五个引用指针的时候，才会开始执行下面的代码。<br>并且也只有添加第五个指针的时候，才会改变<code>out_of_line_ness</code>字段的值，让其标记为已传换成动态数组。<br>另外值得注意的是，在<code>assert(entry-&gt;out_of_line());</code>之前，实际上并没有添加第五个指针，这个指针是通过下面的<code>grow_refs_and_insert</code><br>方法添加的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们能得到大致的结构如图</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzu7az8tqj30p50ez75d.jpg" alt=""></p>
<p><code>SideTables</code>是一个全全局的Hash表，通过对对象地址的<code>hash</code>得到的<code>Index</code>值，从而得到在表中存放的<code>SideTable</code>。<br>每个<code>SideTable</code>都包含了一个自旋锁字段，用于加锁数据读写。此外，还包含一个<code>RefcountMap</code>字段，该字段用于存储<br>对应对象的引用计数。最后<code>weak_table_t</code>是一个全局弱引用表，它将对象地址作为<code>key</code>，<code>weak_entry_t</code>的结构体作为<code>value</code>。<br>其中<code>weak_entry_t</code>会根据弱引用数量来动态改变存储方式，当数量小于<code>WEAK_INLINE_COUNT</code>时，就存储在一个<code>weak_referrer_t</code><br>类型的数组结构中，而大于<code>WEAK_INLINE_COUNT</code>时，就采用<code>weak_referrer_t*</code>指向的动态数组，他会根据自身结构中弱引用数量<br>动态的进行扩容或者缩减。</p>
<p>我们从<code>hash</code>的角度看这个结构来看</p>
<p>1.<code>SideTables</code>e是一个<code>hash</code>表</p>
<p>2.<code>SideTable</code>是一个<code>hash</code>表</p>
<p>3.<code>weak_entries</code>是一个<code>hash</code>表</p>
<p>4.其中<code>SideTable</code>中的<code>refcnts</code>也是一个<code>hash</code>表</p>
<p>前三着都是通过hash的方式分散存储了指针引用<br>第四个用<code>hash</code>存储了引用计数</p>
<p>相关文章</p>
<p><a href="https://www.desgard.com/weak/" target="_blank" rel="noopener">1.weak 弱引用的实现方式</a><br><a href="https://www.cnblogs.com/feng9exe/p/8401354.html" target="_blank" rel="noopener">2.Objective-C 小记（10）__weak</a><br><a href="https://blog.csdn.net/u013378438/article/details/82790332" target="_blank" rel="noopener">3.Objective-C runtime机制(7)——SideTables, SideTable, weak_table, weak_entry_t</a><br><a href="http://www.cocoachina.com/ios/20170328/18962.html" target="_blank" rel="noopener">4.iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）</a></p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/weak/"> #weak </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/03/Hash基本理解/">Hash基本理解</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="http://7xjg07.com1.z0.glb.clouddn.com/u=3987586330,3835281882&fm=21&gp=0.jpg" alt="Deeer" />
          <p class="site-author-name">Deeer</p>
        </div>
        <p class="site-description motion-element">代码手工艺人 | Love Linux  | 追求体验</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/2941461951/profile?topnav=1&wvr=6" target="_blank">weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://github.com/Deeer" target="_blank">github</a>
            </span>
            
          
        </div>

        
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Weak源码分析"><span class="nav-number">1.</span> <span class="nav-text">Weak源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关概念"><span class="nav-number">1.1.</span> <span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SideTables"><span class="nav-number">1.1.1.</span> <span class="nav-text">SideTables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SideTable"><span class="nav-number">1.1.2.</span> <span class="nav-text">SideTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2015 - 
  2018
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Deeer</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  




  
  

</body>
</html>
