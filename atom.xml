<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dee+&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9ec463cf5332e6bd2a44e71301afafd3</icon>
  <subtitle>士不可以不弘毅，任重而道远。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://deeer.github.io/"/>
  <updated>2018-07-07T09:12:01.756Z</updated>
  <id>http://deeer.github.io/</id>
  
  <author>
    <name>Deeer</name>
    <email>dee_code@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>应用启动流程总览</title>
    <link href="http://deeer.github.io/2018/07/07/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%80%BB%E8%A7%88/"/>
    <id>http://deeer.github.io/2018/07/07/应用启动流程总览/</id>
    <published>2018-07-07T07:13:53.000Z</published>
    <updated>2018-07-07T09:12:01.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在编译之前，就进行词法和语法的分析，接着将源代码翻译成中间代码，也就是汇编语言。<br>编译程序工作时，会先分析，最后得到目标程序，所谓的分析也就是对词法和语法的分析。翻译成汇编，最后生成可执行文件</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>每个类都会被编译成不同的目标文件，链接器就是将每个文件串起来，相会调用，生成可执行文件（<code>Mach-O</code>格式）</p><h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p>把已生成的可执行文件放到操作系统的专属进程下，并找到机器可识别的汇编代码入口，开始按照汇编去执行机器码，并能与操作系统级别的API对接。</p><h1 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h1><p>整个编译、链接、装载完成之后，就会回到<code>mian()</code>函数，清空之前的所有线程，并根据代码逻辑进行app展示</p><hr><h1 id="插播"><a href="#插播" class="headerlink" title="插播"></a>插播</h1><blockquote><p>编译型语言 vs 解释型语言</p></blockquote><ul><li><p>编译型语言有单独的编译过程</p></li><li><p>解释型语言在运行的时候将程序翻译成机器语言，速度相对较慢</p></li></ul><p>##LLVM架构</p><p><strong>传统的编译器</strong>分为三个部分：</p><ul><li><strong>前端</strong>：主要负责语法和词法，将源代码生成抽象代码树</li><li><strong>优化器</strong>： 在前端基础上对代码进行优化</li><li><strong>后端</strong>：将优化后的中间代码转为针对各个平台的机器代码</li></ul><p>如图<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft1d6mzyv1j30d60243ye.jpg" alt=""></p><p><a href="https://www.jianshu.com/p/9fc7776cce9b" target="_blank" rel="noopener">这里</a>是LLVM架构的概述</p><blockquote><p>LLVM &amp;&amp; Clang</p></blockquote><ul><li><strong>LLVM</strong> ： 是架构编译器的框架系统，用C++写成。用以优化以任意语言编写的程序的编译时间，链接时间，运行时间及空闲时间。是一个完整的编译器架构，也可以认为是一个用于开发编译器、解释器的相关库</li><li><strong>Clang</strong> ： C++ 编写，基于LLVMBSD许可证下的<code>C/C++/OC++</code>编译器前端（由<code>Apple</code>开发，源代码授权使用<code>BSD</code>的开源授权）</li></ul><h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p><code>dyld</code>是<code>Apple</code>的动态链接库，这一步骤是在<strong>链接</strong>完成之后的生成了<code>Mach-O</code>的可执行文件后，系统已经做好了程序启动的准备，并将控制权交给了<code>dyld</code>。<code>dyld</code>主要负责初始化程序环境，将可执行文件和相应的依赖与库文件加载进内存生成对应的<code>ImageLoader</code>类（也就是镜像文件），对这些文件进行链接，最后调用每个依赖库的初始化方法。与此同时，对程序中的类进行类结构初始化，调用类和分类中的<code>load</code>方法。最后<code>dyld</code>返回<code>main</code>函数，并做清理工作，回归调用栈。</p><h2 id="完整的编译流程如下"><a href="#完整的编译流程如下" class="headerlink" title="完整的编译流程如下"></a>完整的编译流程如下</h2><ul><li>编译信息写入辅助文件，创建<code>.app</code>文件</li><li>处理打包信息</li><li>执行<code>CocoaPod</code>编译前脚本</li><li>编译<code>.m</code>文件，使用<code>Compile</code>和<code>Clang</code>命令</li><li>链接需要的<code>Framework</code></li><li>编译<code>Xib</code></li><li>拷贝<code>Xib</code>，资源文件</li><li>编译<code>ImageAssets</code></li><li>处理<code>info.plist</code></li><li>执行<code>CocoaPod</code>脚本</li><li>拷贝标准库</li><li>创建<code>.app</code>文件和签名</li></ul><hr><h1 id="main之后"><a href="#main之后" class="headerlink" title="main之后"></a>main之后</h1><blockquote><p>main</p></blockquote><p>大致流程：</p><ul><li><code>main</code>函数</li><li>执行<code>UIApplicationMain</code>函数</li><li>创建<code>UIApplication</code>对象</li><li>创建<code>UIApplicationDelegate</code>对象</li><li>创建对应的<code>RunLoop</code>循环</li><li><code>UIApplication</code>开始处理监听到的事件</li><li>读取配置文件<code>info.plist</code>，设置程序启动的一些属性 </li><li>如果<code>plist</code>文件中配置了<code>storyboard</code>文件名，则加载对应的<code>storyboard</code>文件，并根据这个文件中启动配置加载和现实窗口，显示对应的控件。</li><li>如果没有配置，则根据<code>application:didFinishLaunchingWithOptions:</code>代码来创建<code>UIWindow</code></li></ul><blockquote><p> UIApplication</p></blockquote><p>从进入<code>main()</code>方法之后，会创建一个<code>UIApplication</code>对象，他主要做以下几件事:<br>1.从<code>StoryBoard</code>文件加载用户界面<br>2.调用<code>AppDelegate</code>自定义代码类做一些初始化设置<br>3.将app放入<code>main Run Loop</code> 环境来响应和处理与用户交互产生的事件</p><blockquote><p>Main Run Loop </p></blockquote><p> 主要作用：处理所有与用户相关的事件。<code>UIApplication</code>对象在启动时就设置<code>Main Run Loop</code> 和使用他来处理和更新基于<code>view</code>的界面</p><h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft1e0ppxlnj30ft0hp0ta.jpg" alt=""></p><p><strong>NotRun</strong> : 未运行<br><strong>InActive</strong> : 处于<code>Forground</code>状态，但不接收事件<br><strong>Active</strong> : 处于<code>Forground</code>状态，接收事件<br><strong>Background</strong> : 处于<code>Background</code>状态，执行代码<br><strong>Suspend</strong> : 处于<code>Background</code>状态，不执行代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;p&gt;在编译之前，就进行词法和语法的分析，接着将源代码翻译成中间代码，也就是汇编语言。&lt;br&gt;编译程序工作时，会先分析，最后得到目标程序，所谓的分
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://deeer.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>runtime源码阅读 - Category</title>
    <link href="http://deeer.github.io/2018/06/27/runtime%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20-%20Category/"/>
    <id>http://deeer.github.io/2018/06/27/runtime源码阅读 - Category/</id>
    <published>2018-06-26T17:30:35.000Z</published>
    <updated>2018-06-30T06:40:09.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="runtime源码阅读"><a href="#runtime源码阅读" class="headerlink" title="runtime源码阅读"></a>runtime源码阅读</h2><p>首先是对象的初始化</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  void _objcInit(void) &#123;</span><br><span class="line">static int _done = <span class="number">0</span>;</span><br><span class="line">int hidx;</span><br><span class="line">        <span class="comment">/* Protect against multiple invocations, as all library</span></span><br><span class="line"><span class="comment">         * initializers should. */</span></span><br><span class="line">        if (<span class="number">0</span> != _done) return;</span><br><span class="line">        _done = <span class="number">1</span>;</span><br><span class="line">ptrace(<span class="number">0xb010</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// marks call to _objcInit</span></span><br><span class="line">__initialize_objc();</span><br><span class="line"><span class="comment">/* We delay this until here, because dyld cannot detect and</span></span><br><span class="line"><span class="comment"> * properly order calls to ObjC initializers amongst the</span></span><br><span class="line"><span class="comment"> * calls to module and library initializers. */</span></span><br><span class="line">for (hidx = <span class="number">0</span>; hidx &lt; header_count; hidx += <span class="number">1</span>)</span><br><span class="line">_objc_call_loads_for_image (&amp;header_vector[hidx]);</span><br><span class="line">ptrace(<span class="number">0xb01f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// marks call to _objcInit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是以下这段代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hidx;</span><br><span class="line">        <span class="comment">/* Protect against multiple invocations, as all library</span></span><br><span class="line"><span class="comment">         * initializers should. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != _done) <span class="keyword">return</span>;</span><br><span class="line">        _done = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>正如他所写的，这个逻辑防止了被多次调用执行，保证了该方法只被执行一次。因为一旦第一次执行了，那么<code>_done</code>这个参数就会被赋值为1，之后调用就会直接<code>return</code></p><p>接下来，这里有个<code>ptrace</code>方法,这个方法主要用于断点调试和追踪系统调用。对于实现整体的逻辑实现没有太大影响，我们可以将它忽略。</p><p>之后调用了<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__initialize_objc()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>该方法是动态链接器用来初始化库文件，通过头文件创建了一个全局的迭代器，并通过类的<code>hash</code>表，和对应头文件的迭代器来获取<code>class</code>。</p><h2 id="category-部分"><a href="#category-部分" class="headerlink" title="category 部分"></a>category 部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Library initializer called by dyld. */</span></span><br><span class="line"><span class="keyword">void</span> __initialize_objc(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> hidx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NeXT_PDO)</span></span><br><span class="line"><span class="keyword">const</span> headerType * <span class="keyword">const</span> *headers;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( rocketLaunchingDebug == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( getenv(<span class="string">"OBJC_UNIQUE_DEBUG"</span>) ) rocketLaunchingDebug = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> rocketLaunchingDebug = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get architecture dependent module headers</span></span><br><span class="line">headers = (<span class="keyword">const</span> headerType * <span class="keyword">const</span> *) _getObjcHeaders ();</span><br><span class="line"><span class="keyword">if</span> (headers)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create vector from these headers</span></span><br><span class="line">header_vector = _objc_headerVector (headers);</span><br><span class="line"><span class="keyword">if</span> (header_vector) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Load classes from all images in the vector</span></span><br><span class="line"><span class="keyword">for</span> (hidx = <span class="number">0</span>; hidx &lt; header_count; hidx += <span class="number">1</span>)</span><br><span class="line">(<span class="keyword">void</span>) _objc_get_classes_from_image (class_hash, &amp;header_vector[hidx]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__MACH__)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __CFInitialize(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Protect against multiple invocations, as all library</span></span><br><span class="line"><span class="comment"> * initializers should. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != _done) <span class="keyword">return</span>;</span><br><span class="line">_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ptrace(<span class="number">0xb000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure CF is initialized before we go further;</span></span><br><span class="line"><span class="comment">// someday this can be removed, as it'll probably be automatic</span></span><br><span class="line">__CFInitialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the class lookup table</span></span><br><span class="line">_objc_init_class_hash ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb001, 0, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get our configuration</span></span><br><span class="line">        <span class="keyword">if</span> ( rocketLaunchingDebug == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( getenv(<span class="string">"OBJC_UNIQUE_DEBUG"</span>) ) rocketLaunchingDebug = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> rocketLaunchingDebug = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb003, 0, 0, 0);</span></span><br><span class="line"></span><br><span class="line">map_selectors_pended = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXXXX BEFORE HERE *NO* PAGES ARE STOMPED ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register our image mapping routine with dyld so it</span></span><br><span class="line"><span class="comment">// gets invoked when an image is added.  This also invokes</span></span><br><span class="line"><span class="comment">// the callback right now on any images already present.</span></span><br><span class="line">_dyld_register_func_for_add_image (&amp;_objc_map_image_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXXXX BEFORE HERE *ALL* PAGES ARE STOMPED ON</span></span><br><span class="line"></span><br><span class="line">map_selectors_pended  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb005, 0, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register module link callback with dyld</span></span><br><span class="line">_dyld_register_func_for_link_module (&amp;_objc_link_module_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register callback with dyld</span></span><br><span class="line">_dyld_register_func_for_unlink_module (&amp;_objc_unlink_module_callback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MACH</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb006, header_count, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install relations on classes that were found</span></span><br><span class="line"><span class="keyword">for</span> (hidx = <span class="number">0</span>; hidx &lt; header_count; hidx += <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>nModules;</span><br><span class="line"><span class="keyword">int</span>index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_module</span> *<span class="title">module</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">cls</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> = (struct objc_module *) ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) header_vector[hidx].mod_ptr + header_vector[hidx].image_slide);</span><br><span class="line"><span class="keyword">for</span> (nModules = header_vector[hidx].mod_count; nModules; nModules -= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="keyword">module</span>-&gt;symtab-&gt;cls_def_cnt; index += <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cls = (struct objc_class *) <span class="keyword">module</span>-&gt;symtab-&gt;defs[index];</span><br><span class="line">_class_install_relationships (cls, <span class="keyword">module</span>-&gt;version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb007, hidx, header_vector[hidx].mod_count, 0);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb008, header_count, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (hidx = <span class="number">0</span>; hidx &lt; header_count; hidx += <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__MACH__)</span></span><br><span class="line">(<span class="keyword">void</span>)_objc_add_categories_from_image (&amp;header_vector[hidx]);</span><br><span class="line">(<span class="keyword">void</span>) _objc_fixup_selector_refs (&amp;header_vector[hidx]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// Initialize the isa pointers of all NXConstantString objects</span></span><br><span class="line">(<span class="keyword">void</span>)_objc_fixup_string_objects_for_image (&amp;header_vector[hidx]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert class refs from name pointers to ids</span></span><br><span class="line">(<span class="keyword">void</span>)_objc_map_class_refs_for_image (&amp;header_vector[hidx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace(0xb00a, 0, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For each image selectorize the method names and +_fixup each of</span></span><br><span class="line"><span class="comment">// protocols in the image</span></span><br><span class="line"><span class="keyword">for</span> (hidx = <span class="number">0</span>; hidx &lt; header_count; hidx += <span class="number">1</span>)</span><br><span class="line">_objc_fixup_protocol_objects_for_image (&amp;header_vector[hidx]);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WIN32) || defined(__svr4__)</span></span><br><span class="line">CMH = (objcModHeader *) <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ptrace(<span class="number">0xb00f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// end of ObjC init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法中，其中一个比较重要的方法就是</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_objc_get_classes_from_image<span class="comment">()</span></span><br></pre></td></tr></table></figure><p>让我们继续往里深入这个方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> * _objc_get_classes_from_image.  Install all classes contained in the</span></span><br><span class="line"><span class="comment"> * specified image.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> NXHashTable *_objc_get_classes_from_image   (NXHashTable *clsHash,</span><br><span class="line">header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">unsigned intindex;</span><br><span class="line">unsigned intmidx;</span><br><span class="line">Modulemods;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Major loop - process all modules in the image</span></span><br><span class="line">mods = (Module) ((unsigned long) hi-&gt;mod_ptr + hi-&gt;image_slide);</span><br><span class="line"><span class="keyword">for</span> (midx = <span class="number">0</span>; midx &lt; hi-&gt;mod_count; midx += <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Skip module containing no classes</span></span><br><span class="line"><span class="keyword">if</span> (mods[midx].symtab == NULL)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Minor loop - process all the classes in given module</span></span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; mods[midx].symtab-&gt;cls_def_cnt; index += <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">struct objc_class *oldCls;</span><br><span class="line">struct objc_class *<span class="keyword">new</span><span class="type">Cls</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Locate the class description pointer</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Cls</span> = mods[midx].symtab-&gt;defs[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert old style method list to the new style</span></span><br><span class="line">_objcTweakMethodListPointerForClass (<span class="keyword">new</span><span class="type">Cls</span>);</span><br><span class="line"></span><br><span class="line">oldCls = NXHashInsert (clsHash, <span class="keyword">new</span><span class="type">Cls</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-Nil oldCls is a class that NXHashInsert just</span></span><br><span class="line"><span class="comment">// bumped from table because it has the same name</span></span><br><span class="line"><span class="comment">// as newCls</span></span><br><span class="line"><span class="keyword">if</span> (oldCls)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> defined(__MACH__)</span></span><br><span class="line">const header_info *oldHeader;</span><br><span class="line">const header_info *<span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">const char *oldName;</span><br><span class="line">const char *<span class="keyword">new</span><span class="type">Name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log the duplication</span></span><br><span class="line">oldHeader = _headerForClass (oldCls);</span><br><span class="line"><span class="keyword">new</span><span class="type">Header</span> = _headerForClass (<span class="keyword">new</span><span class="type">Cls</span>);</span><br><span class="line">oldName   = _nameForHeader  (oldHeader-&gt;mhdr);</span><br><span class="line"><span class="keyword">new</span><span class="type">Name</span>   = _nameForHeader  (<span class="keyword">new</span><span class="type">Header</span>-&gt;mhdr);</span><br><span class="line">_objc_inform (<span class="string">"Both %s and %s have implementations of class %s."</span>,</span><br><span class="line">oldName, <span class="keyword">new</span><span class="type">Name</span>, oldCls-&gt;name);   </span><br><span class="line">_objc_inform (<span class="string">"Using implementation from %s."</span>, <span class="keyword">new</span><span class="type">Name</span>);</span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the chosen class</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Isn't this a NOP?</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Cls</span> = objc_lookUpClass (oldCls-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unless newCls was a duplicate, and we chose the</span></span><br><span class="line"><span class="comment">// existing one instead, set the version in the meta-class</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Cls</span> != oldCls)</span><br><span class="line"><span class="keyword">new</span><span class="type">Cls</span>-&gt;isa-&gt;version = mods[midx].version;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Install new categories intended for this class</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> But, if we displaced an existing "isEqual"</span></span><br><span class="line"><span class="comment">// class, the categories have already been installed</span></span><br><span class="line"><span class="comment">// on an old class and are gone from the registry!!</span></span><br><span class="line">_objc_resolve_categories_for_class (<span class="keyword">new</span><span class="type">Cls</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resolve (a) pointers to the named class, and/or</span></span><br><span class="line"><span class="comment">// (b) the super_class, cache, and version</span></span><br><span class="line"><span class="comment">// fields of newCls and its meta-class</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> But, if we displaced an existing "isEqual"</span></span><br><span class="line"><span class="comment">// class, this has already been done... with an</span></span><br><span class="line"><span class="comment">// old-now-"unused" class!!</span></span><br><span class="line">checkForPendingClassReferences (<span class="keyword">new</span><span class="type">Cls</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NeXT_PDO) // GENERIC_OBJ_FILE</span></span><br><span class="line"><span class="comment">// Invoke registered callback</span></span><br><span class="line"><span class="keyword">if</span> (load_class_callback)</span><br><span class="line">(*load_class_callback) (<span class="keyword">new</span><span class="type">Cls</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call +finishLoading:: from the class' method list</span></span><br><span class="line">send_load_message_to_class (<span class="keyword">new</span><span class="type">Cls</span>, (headerType *) hi-&gt;mhdr);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the table the caller passed</span></span><br><span class="line"><span class="keyword">return</span> clsHash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从顶部的注释中，我们可以了解到，这个方法用于加载指定镜像中的所有的类<br>这里我们关注的是category的部分，所以我们看到行代码<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   // <span class="keyword">Install</span> <span class="keyword">new</span> categories intended <span class="keyword">for</span> this <span class="keyword">class</span></span><br><span class="line">// NOTE: But, <span class="keyword">if</span> we displaced an existing <span class="string">"isEqual"</span></span><br><span class="line">// <span class="keyword">class</span>, the categories have already been installed</span><br><span class="line">// <span class="keyword">on</span> an <span class="keyword">old</span> <span class="keyword">class</span> <span class="keyword">and</span> <span class="keyword">are</span> gone <span class="keyword">from</span> the registry!!</span><br><span class="line">_objc_resolve_categories_for_class (newCls);</span><br></pre></td></tr></table></figure></p><p>该方法被用于加载新的<code>category</code>，注释中也提到了，如果我们取代了已经存在的同一个类，那么之前已经被加载在旧的类上的<code>category</code>就会从寄存器中消失</p><p>对应的是现实这样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="emphasis">_objc_</span>resolve<span class="emphasis">_categories_</span>for_class.  Install all categories intended</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * for </span>the<span class="markdown"> specified class, in reverse order from </span>the<span class="markdown"> order in which we</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * found </span>the<span class="markdown"> categories in </span>the<span class="markdown"> image.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>_objc_resolve_categories_for_class  (struct objc_class *cls)</span><br><span class="line">&#123;</span><br><span class="line">_objc_unresolved_category *cat;</span><br><span class="line">_objc_unresolved_category *next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nothing to do if there are no categories at all</span></span><br><span class="line"><span class="keyword">if</span> (!category_hash)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Locate and remove first element in category list</span></span><br><span class="line"><span class="comment">// associated with this class</span></span><br><span class="line">cat = NXMapRemove (category_hash, cls-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse the list of categories, if any, registered for this class</span></span><br><span class="line"><span class="keyword">while</span> (cat)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Install the category</span></span><br><span class="line">_objc_add_category (cat-&gt;cat, cat-&gt;version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delink and reclaim this registration</span></span><br><span class="line">next = cat-&gt;next;</span><br><span class="line">free (cat);</span><br><span class="line">cat = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们观察到有个叫<code>category_hash</code>的哈希表，之后遍历单向链表结构，将对应的<code>category</code>添加到对象中</p><p>这里我们会有两个疑问🤔️</p><p>1.<code>category_hash</code>这个变量那里来的？<br>2.<code>_objc_add_category</code>又做了什么操作？</p><hr><p>那么我们先解答第一个</p><blockquote><p>1.<code>category_hash</code>这个变量那里来的？</p></blockquote><p>事实上，<code>category_hash</code>是一个全局变量<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Category <span class="literal">and</span> <span class="class"><span class="keyword">class</span> <span class="title">registries</span></span></span><br><span class="line">static NXMapTable *category_hash = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>在<code>__initialize_objc()</code>这个方法中有这样一行代码</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// Register our image mapping routine with dyld so it</span></span><br><span class="line"><span class="comment">// gets invoked when an image is added.  This also invokes</span></span><br><span class="line"><span class="comment">// the callback right now on any images already present.</span></span><br><span class="line"><span class="variable">_dyld_register_func_for_add_image</span> (&amp;<span class="variable">_objc_map_image_callback</span>);</span><br></pre></td></tr></table></figure><p>在这个方式中，我们传入了一个回调方法，也就是说当每个镜像被加载的时候都会调用这个回调方法，具体可见<a href="http://mirror.informatimago.com/next/developer.apple.com/documentation/DeveloperTools/Conceptual/MachORuntime/5rt_api_reference/chapter_11_section_46.html" target="_blank" rel="noopener">这里</a></p><p>之后经过一系列调用最终在<code>_objc_register_category</code>这个方法中创建了这个<code>category</code>哈希表</p><p><strong>所以</strong></p><p>这个哈希表的创建是在每次镜像被加载时创建的，同时他也会去做对比，如果出现重复就会进行替换操作</p><hr><blockquote><p>2.<code>_objc_add_category</code>又做了什么操作？</p></blockquote><p>直接看代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="emphasis">_objc_</span>add_category.  Install </span>the<span class="markdown"> specified category's methods into</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span>the<span class="markdown"> class it augments, and flush </span>the<span class="markdown"> class' method cache.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * Private extern used by objc_loadModules ()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">void</span>_objc_add_category     (struct objc_category *category,</span><br><span class="line"><span class="built_in">int</span>version)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Install the category's methods into its intended class</span></span><br><span class="line">__objc_add_category (category, version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush caches so category's methods can get called</span></span><br><span class="line">_objc_flush_caches (objc_lookUpClass (category-&gt;class_name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释十分清晰，主要干了<strong>两件事</strong></p><ul><li>1.加载特定类方法</li><li>2.刷新类的方法缓存</li></ul><p>关于<code>__objc_add_category</code>我们需要进一步去深入</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> * __objc_add_category.  Install the specified category's methods and</span></span><br><span class="line"><span class="comment"> * protocols into the class it augments.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line">static inline void__objc_add_category    (struct objc_category *category,</span><br><span class="line">intversion)</span><br><span class="line">&#123;</span><br><span class="line">struct objc_class *cls;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Locate the class that the category will extend</span></span><br><span class="line"><span class="function"><span class="title">cls</span> = (struct objc_class *) objc_getClass (category-&gt;</span>class_name);</span><br><span class="line"><span class="keyword">if</span> (!cls)</span><br><span class="line">&#123;</span><br><span class="line">_<span class="function"><span class="title">objc_inform</span> ("unable to add category %s...\n", category-&gt;</span>category_name);</span><br><span class="line">_<span class="function"><span class="title">objc_inform</span> ("class `%s' <span class="built_in">not</span> linked into application\n", category-&gt;</span>class_name);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Augment instance methods</span></span><br><span class="line"><span class="function"><span class="title">if</span> (category-&gt;</span>instance_methods)</span><br><span class="line">_<span class="function"><span class="title">objc_insertMethods</span> (category-&gt;</span><span class="function"><span class="title">instance_methods</span>, &amp;cls-&gt;</span>methodLists);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Augment class methods</span></span><br><span class="line"><span class="function"><span class="title">if</span> (category-&gt;</span>class_methods)</span><br><span class="line">_<span class="function"><span class="title">objc_insertMethods</span> (category-&gt;</span><span class="function"><span class="title">class_methods</span>, &amp;cls-&gt;</span><span class="function"><span class="title">isa</span>-&gt;</span>methodLists);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Augment protocols</span></span><br><span class="line"><span class="function"><span class="title">if</span> ((version &gt;= 5) &amp;&amp; category-&gt;</span>protocols)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">if</span> (cls-&gt;</span><span class="function"><span class="title">isa</span>-&gt;</span>version &gt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">category</span>-&gt;</span><span class="function"><span class="title">protocols</span>-&gt;</span><span class="function"><span class="title">next</span> = cls-&gt;</span>protocols;</span><br><span class="line"><span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">protocols</span>          = category-&gt;</span>protocols;</span><br><span class="line"><span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">isa</span>-&gt;</span><span class="function"><span class="title">protocols</span>       = category-&gt;</span>protocols;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">_<span class="function"><span class="title">objc_inform</span> ("unable to add protocols from category %s...\n", category-&gt;</span>category_name);</span><br><span class="line">_<span class="function"><span class="title">objc_inform</span> ("class `%s' must be recompiled\n", category-&gt;</span>class_name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(NeXT_PDO) <span class="comment">// GENERIC_OBJ_FILE</span></span><br><span class="line"><span class="comment">// Call back</span></span><br><span class="line"><span class="keyword">if</span> (load_class_callback)</span><br><span class="line">(*load_class_callback) (cls, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call +finishLoading:: from the category's method list</span></span><br><span class="line">send_load_message_to_category (category, (void *) header_vector[<span class="number">0</span>].mhdr);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，他会分别对<strong>实例对象的方法列表</strong>和<strong>类对象的方法列表</strong>分别添加实例方法和类方法。</p><p>总结： </p><p>1.<code>dyld</code>在每次加载镜像的时候，都会调用回调方法，让系统生成类对应的<code>category</code>哈希表<br>2.每次对应添加方法时都会是分别添加对应的实例方法和类方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;runtime源码阅读&quot;&gt;&lt;a href=&quot;#runtime源码阅读&quot; class=&quot;headerlink&quot; title=&quot;runtime源码阅读&quot;&gt;&lt;/a&gt;runtime源码阅读&lt;/h2&gt;&lt;p&gt;首先是对象的初始化&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="ScourceCode" scheme="http://deeer.github.io/categories/ScourceCode/"/>
    
    
      <category term="Runtime" scheme="http://deeer.github.io/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>加密相关（二）</title>
    <link href="http://deeer.github.io/2018/06/25/%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://deeer.github.io/2018/06/25/加密相关（二）/</id>
    <published>2018-06-25T07:44:42.000Z</published>
    <updated>2018-06-25T08:33:46.237Z</updated>
    
    <content type="html"><![CDATA[<p>基于第一篇文章的介绍，接下来我们来聊聊日常生活中的都会接触到的加密应用方式–<code>HTTPS</code></p><h2 id="HTTP-vs-HTTPS"><a href="#HTTP-vs-HTTPS" class="headerlink" title="HTTP vs HTTPS"></a>HTTP vs HTTPS</h2><p><code>HTTP</code>全称<code>Hyper Text Transfer Protocal</code>(超文本传输协议)是万维网服务器传输超文本协议到本地浏览器的传送协议，是一个属于应用层的面向对象的协议。</p><p><code>HTTPS</code>全称<code>Secure Hypertext Transfer Protocol</code>安全超文本传输协议。</p><h2 id="SSL-or-TLS"><a href="#SSL-or-TLS" class="headerlink" title="SSL or TLS"></a>SSL or TLS</h2><p>在<code>HTTPS</code>中的<code>S</code>可以是<code>SSL</code>或者<code>TLS</code>。</p><p><code>SSL</code>全称<code>Secure Socket Layer</code>安全套接字层，位于可靠的面向连接的网络协议和应用层协议层。<code>SSL</code>通过互相认证、使用数字证书保证完整性，使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成: <code>SSL</code>记录协议和<code>SSL</code>握手协议。<code>SSL</code>是<code>Netscape</code>开发的专门用于保护<code>Web</code>通讯的。</p><p><code>TLS</code>全称<code>Transport Layer Security</code>安全传输层协议，用于两个应用之间提供保密性和数据完整性。该协议由两层组成:  <code>TSL</code>记录协议和<code>TSL</code>握手协议。<br> <a id="more"></a> </p><p><strong>联系</strong>：网景公司为了保护网络传输，发明了SSL，到了1999年，SSL因为应用广泛，已经成为互联网上的事实标准，IETF就在那年把SSL标准化，标准化后的名称改为TSL，所以他们可以视为一个东西在不同阶段的名称</p><hr><p>OK 接下来，我们来了解一下，在<code>iOS</code>中的两种<code>SSL</code>加密方式</p><h2 id="单向认证-和-双向认证"><a href="#单向认证-和-双向认证" class="headerlink" title="单向认证 和 双向认证"></a>单向认证 和 双向认证</h2><h3 id="单向认证流程"><a href="#单向认证流程" class="headerlink" title="单向认证流程"></a>单向认证流程</h3><p>1.客户<code>say hello to</code> 服务端<br>2.服务端将证书、公钥等发送给客户端<br>3.客户端<code>CA</code>验证证书，成功继续、不成功弹出选择页面<br>4.客户端告知服务端所支持的加密算法<br>5.服务端选择最高级别加密算法明文通知客户端<br>6.客户端随机生成对称密钥<code>key</code>， 使用服务端公钥进行加密，并发送给服务端<br>7.服务端使用私钥解密，获取对称密钥<code>key</code><br>8.后续客户端端使用该密钥<code>key</code>进行加密通信<br>具体流程图是这样的<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fsni1afkv8j30mp0i8gmx.jpg" alt=""></p><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>1.客户端<code>say hello to</code> 服务端<br>2.服务端将证书、公钥等发送给客户端<br>3.客户端证<code>CA</code>验证证书，成功继续、不成功弹出选择页面</p><p>4.客户端将自己的证书和公钥发送给服务端<br>5.服务端验证客户端证书，如果不通过直接断开连接</p><p>6.客户端告知服务端所支持的所有加密算法<br>7.服务端选择最高级别加密算法使用客户端的公钥加密后发送给客户端<br>8.客户端收到后使用私钥解密并生成随机密匙<code>key</code>，使用服务端公钥加密发送给服务端<br>9.服务端使用私钥解密，获取对称密钥<code>key</code><br>10.后续客户端与服务端使用该密钥<code>key</code>进行加密通信<br>具体流程如下<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fsni88rmbrj31a0110wjg.jpg" alt=""></p><p>总结： 单向认证<code>SSL</code>协议，不需要客户端拥有<code>CA</code>证书，只要客户端通过服务端发送过来的证书即可。一般的<code>web</code>应用都采用单向认证的方式，因为用户数目广泛，且无需在通讯层验证用户身份合法性，一般都采用应用逻辑来保证用户的合法性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于第一篇文章的介绍，接下来我们来聊聊日常生活中的都会接触到的加密应用方式–&lt;code&gt;HTTPS&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;HTTP-vs-HTTPS&quot;&gt;&lt;a href=&quot;#HTTP-vs-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTP vs HTTPS&quot;&gt;&lt;/a&gt;HTTP vs HTTPS&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;全称&lt;code&gt;Hyper Text Transfer Protocal&lt;/code&gt;(超文本传输协议)是万维网服务器传输超文本协议到本地浏览器的传送协议，是一个属于应用层的面向对象的协议。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt;全称&lt;code&gt;Secure Hypertext Transfer Protocol&lt;/code&gt;安全超文本传输协议。&lt;/p&gt;
&lt;h2 id=&quot;SSL-or-TLS&quot;&gt;&lt;a href=&quot;#SSL-or-TLS&quot; class=&quot;headerlink&quot; title=&quot;SSL or TLS&quot;&gt;&lt;/a&gt;SSL or TLS&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;HTTPS&lt;/code&gt;中的&lt;code&gt;S&lt;/code&gt;可以是&lt;code&gt;SSL&lt;/code&gt;或者&lt;code&gt;TLS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SSL&lt;/code&gt;全称&lt;code&gt;Secure Socket Layer&lt;/code&gt;安全套接字层，位于可靠的面向连接的网络协议和应用层协议层。&lt;code&gt;SSL&lt;/code&gt;通过互相认证、使用数字证书保证完整性，使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成: &lt;code&gt;SSL&lt;/code&gt;记录协议和&lt;code&gt;SSL&lt;/code&gt;握手协议。&lt;code&gt;SSL&lt;/code&gt;是&lt;code&gt;Netscape&lt;/code&gt;开发的专门用于保护&lt;code&gt;Web&lt;/code&gt;通讯的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TLS&lt;/code&gt;全称&lt;code&gt;Transport Layer Security&lt;/code&gt;安全传输层协议，用于两个应用之间提供保密性和数据完整性。该协议由两层组成:  &lt;code&gt;TSL&lt;/code&gt;记录协议和&lt;code&gt;TSL&lt;/code&gt;握手协议。&lt;br&gt;
    
    </summary>
    
      <category term="Read iOS" scheme="http://deeer.github.io/categories/Read-iOS/"/>
    
    
      <category term="Encryption" scheme="http://deeer.github.io/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout探索</title>
    <link href="http://deeer.github.io/2018/06/02/setTimeout%E6%8E%A2%E7%B4%A2/"/>
    <id>http://deeer.github.io/2018/06/02/setTimeout探索/</id>
    <published>2018-06-02T07:02:55.000Z</published>
    <updated>2018-06-02T07:19:43.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><blockquote><p>并发&amp;&amp;并行</p></blockquote><p><strong>并发多线程</strong> : <code>ConCurrency</code> , 实质就是一个物理的<code>CPU</code>在若干个程序之间复用，由于每次切换执行程序的时间极短，所以一般用户无法察觉，即认为是多个应用在同时执行。<br><strong>并行多线程</strong> : <code>Paralleism</code> , 指两个或两个以上的事件在同一时刻发生，是真正意义上的不同事件在同一个时刻发送。</p><blockquote><p>JS线程</p></blockquote><p>浏览器内核是多线程的，在一般情况下，会保留至少三个基本线程：<strong>JS引擎线程</strong>、<strong>GUI渲染线程</strong>、<strong>浏览器事件触发线程</strong></p><p><strong>JS引擎线程</strong>: 基于事件执行，单线程处理，意味着任务都是一个接一个顺序执行的。<br><strong>GUI渲染线程</strong>: 负责渲染浏览器界面<br><strong>浏览器事件触发线程</strong>: 当一个事件触发时该线程会把事件添加到<code>JS引擎线程</code>的待处理队列的队尾中</p><a id="more"></a><p>其中要注意的是，<code>JS引擎线程</code>和<code>GUI渲染线程</code>是的<strong>互斥关系</strong>。</p><hr><h2 id="setTimeOut"><a href="#setTimeOut" class="headerlink" title="setTimeOut"></a>setTimeOut</h2><p>在代码执行时，当<code>JS</code>遇到<code>setTimeout</code>方法时，会将回调函数放在一个任务队列中，当<code>JS线程</code>空闲之后或达到设定的时间之后，执行任务队列中的任务。<br>这就解释了为什么在<code>for</code>循环中设定<code>setTimeout</code>方法的时候，并不会立刻执行，而是在其他代码执行完成之后，再去执行。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frwunjzpuqj30e60b2wf8.jpg" alt=""></p><p>这里我们看到的最终输出的<code>i</code>是<code>3</code>个<code>4</code>，这就意味着，<code>setTimeout</code>方法的执行是在循环结束之后执行的，并且每一次循环都在队列中添加了一次回调函数，并且这回回调函数并没有直接捕捉当次循环中i的值，这也说明了回调函数是在循环之后再执行。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>在研究这个执行特性的时候还发现了一个好玩的东西: 放在队列中的回调函数，执行的执行顺序，会随设定的时间做一些微妙的变化</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frwuoi73jxj30dm0hygmr.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frwupr68bwj30eg0e0myb.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frwuqb41i8j30ds0dimya.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frwuqt6plhj30fa0d8dgz.jpg" alt=""></p><p>我们可以看到，同样的代码，只有在设定时间为<code>0</code>和<code>1</code>的时候，两个回调方法才会按代码的顺序依次执行，<br>起初我认为是时差查导致的，所以，是不是之后在相差1毫秒的情况下，才会发生这种情况呢？<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frwur8w6xwj30em0dk75f.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frwursy48tj30h80ccgmr.jpg" alt=""><br>实践告诉我们并不是，同样的<code>2毫秒</code>和<code>3毫秒</code>、<code>3毫秒</code>和<code>4毫秒</code>的情况下。<br>这种执行顺序，我们可以理解为到达了<code>setTimeout</code>设置的回调时间。</p><p>那么到底和时差有没有关系呢？我这里又做了两组对比实验<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frwuseyqozj30ge0cc75f.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frwuslrn35j30gc0ca75f.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frwusv9hllj30gy0gk75h.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frwut3co22j30gc0gyq44.jpg" alt=""></p><p>这组对比告诉我们,回调时间决定了回调函数的执行先后。在不为<code>0</code>或<code>1</code> 的普遍情况下，执行的顺序是按时间的顺序，从短到长按满足条件先后依次执行的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>最基本的一点，在<code>setTimeout</code>中设置的回调函数和在<code>for循环</code>中的函数的执行优先级不同，<code>setTimeout</code>的回调函数会等待线程空闲时或满足条件时进行处理。所以，回调函数总是后来触发。</li><li>在存在多个<code>setTimeout</code>回调的情况下。一般来讲，执行顺序和时间有关，先满足时间条件的函数优先执行代码，如果时间相同则会顺序执行回调。</li><li><code>setTimeout</code>只是将事件插入到任务队列,必须等到当前代码都执行完成之后，主线程才会去执行他指定的回调函数。所以普遍意义上讲，这个时间只是一种优先级的标记，但<code>0毫秒</code>和<code>1毫秒</code>优先级，目前看来是一样的，不会因为数值大小而发生顺序变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;并发&amp;amp;&amp;amp;并行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;并发多线程&lt;/strong&gt; : &lt;code&gt;ConCurrency&lt;/code&gt; , 实质就是一个物理的&lt;code&gt;CPU&lt;/code&gt;在若干个程序之间复用，由于每次切换执行程序的时间极短，所以一般用户无法察觉，即认为是多个应用在同时执行。&lt;br&gt;&lt;strong&gt;并行多线程&lt;/strong&gt; : &lt;code&gt;Paralleism&lt;/code&gt; , 指两个或两个以上的事件在同一时刻发生，是真正意义上的不同事件在同一个时刻发送。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JS线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;浏览器内核是多线程的，在一般情况下，会保留至少三个基本线程：&lt;strong&gt;JS引擎线程&lt;/strong&gt;、&lt;strong&gt;GUI渲染线程&lt;/strong&gt;、&lt;strong&gt;浏览器事件触发线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS引擎线程&lt;/strong&gt;: 基于事件执行，单线程处理，意味着任务都是一个接一个顺序执行的。&lt;br&gt;&lt;strong&gt;GUI渲染线程&lt;/strong&gt;: 负责渲染浏览器界面&lt;br&gt;&lt;strong&gt;浏览器事件触发线程&lt;/strong&gt;: 当一个事件触发时该线程会把事件添加到&lt;code&gt;JS引擎线程&lt;/code&gt;的待处理队列的队尾中&lt;/p&gt;
    
    </summary>
    
      <category term="FrontEnd" scheme="http://deeer.github.io/categories/FrontEnd/"/>
    
    
      <category term="tips" scheme="http://deeer.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>加密相关（一）</title>
    <link href="http://deeer.github.io/2018/05/23/%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://deeer.github.io/2018/05/23/加密相关（一）/</id>
    <published>2018-05-23T13:31:06.000Z</published>
    <updated>2018-06-25T07:44:23.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br> <strong>这会是一篇主讲加密相关的文章，希望能在一定程度上理清日常使用的加密概念。</strong></p></blockquote><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>首先，现有的加密技术分为两种，一种叫<code>对称加密</code>，即在加密和解密的时候使用的是同一个密钥。另一种叫<code>非对称加密</code>，这种加密技术中，存在两个概念—私钥和公钥。私钥一般是指，用于加密原文的不向外界透露的密钥。公钥则想法，一般是指向外界透露的，用于解密的密钥。其中公钥和私钥是一一对应关系，即只有私钥对应的公钥才能解密私钥加密的密文</p><hr> <a id="more"></a> <h3 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h3><p>他是对原文的信息提炼，通常长度比原文小，且具有<strong>固定的长度</strong>，<strong>不可逆</strong>等特点。对于改变输入值中的任何一个字符，都会得到一个截然不同的结果，这种雪崩效应，对于信息验证来说再好不过了。所以单向散列函数常用于消息摘要、密钥加密等。比较为人熟知的有MD5、SHA等</p><hr><h3 id="消息认证码-–-Message-authentication-code"><a href="#消息认证码-–-Message-authentication-code" class="headerlink" title="消息认证码 – Message authentication code"></a>消息认证码 – Message authentication code</h3><p>他是一种确认完整性的的技术，缩写<code>MAC</code>。消息认证码输入的是<strong>任意长度的消息</strong>和一个<strong>发送者与接收者共享的密钥</strong>，输出的固定长度的数据，就叫<strong>MAC值</strong></p><p>可以用于确定消息是否被改动，同时能确认消息是否来自期待的通信对象，因为<strong>密钥是共享的</strong>。</p><hr><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是前加密技术的组合应用。首先，将消息生成散列值，并用私钥进行加密，最后将原文、公钥和密文一起发送给对方。当接收方拿到数据后，可以通过公钥解密得到密文，再将原文进行散列运算，最后比较两者的吻合度即可验证数据的完整性和有效性。</p><hr><h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><p><code>CA</code>证书，又称数字证书，他由权威机构给某个网站颁发的一种认可凭证。这个凭证能告诉大家（浏览器）所认可的，在访问的网站的时候，会验证该站点上的CA证书，如果浏览器发现该证书没有问题，那么就可以直接打开，否则的话，浏览器就会发出警告，告诉你该网站的证书存在问题，是否继续访问该站点。</p><p>在<code>HTTP</code>中，<code>SSL</code>（<code>Secure Sockets Layer</code>）作为在传输层的上网络连接加密层，我们可以形象理解他为一传输通道加密，而<code>CA</code>证书则是对传输双方提供一种点对点的加密方式。</p><hr><h2 id="常见使用案例"><a href="#常见使用案例" class="headerlink" title="常见使用案例"></a>常见使用案例</h2><blockquote><p>对称加密算法  </p></blockquote><p>  <code>AES</code> :  加密和解密都使用同一个密钥</p><p>  <code>DES</code> : 速度快，适用加密大量数据场合</p><p>  <code>3DES</code> : 加密强度更高</p><blockquote><p>非对称加密算法</p></blockquote><p>  <code>RSA</code> : 公钥私钥一对一，并且相互无法反推</p><blockquote><p>单向散列函数</p></blockquote><p>  <code>MD5</code> :  不可逆，但相同数据的MD5值相同,值定长,可以用库撞出结果</p><p>  <code>BASE64</code> : 准确说，<code>BASE64</code>不算加密，而是给内容转换编码，让人不能一眼就能看出内容。</p><p>  <code>SHA</code> : <code>Secure Hash Algorithm</code>，是一个大家族，其中成员包括<code>SHA-1</code>、<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt; &lt;strong&gt;这会是一篇主讲加密相关的文章，希望能在一定程度上理清日常使用的加密概念。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对称加密与非对称加密&quot;&gt;&lt;a href=&quot;#对称加密与非对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密与非对称加密&quot;&gt;&lt;/a&gt;对称加密与非对称加密&lt;/h3&gt;&lt;p&gt;首先，现有的加密技术分为两种，一种叫&lt;code&gt;对称加密&lt;/code&gt;，即在加密和解密的时候使用的是同一个密钥。另一种叫&lt;code&gt;非对称加密&lt;/code&gt;，这种加密技术中，存在两个概念—私钥和公钥。私钥一般是指，用于加密原文的不向外界透露的密钥。公钥则想法，一般是指向外界透露的，用于解密的密钥。其中公钥和私钥是一一对应关系，即只有私钥对应的公钥才能解密私钥加密的密文&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Read" scheme="http://deeer.github.io/categories/Read/"/>
    
    
      <category term="Encryption" scheme="http://deeer.github.io/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>autoreleasepool分析</title>
    <link href="http://deeer.github.io/2018/04/12/autoreleasepool%E5%88%86%E6%9E%90/"/>
    <id>http://deeer.github.io/2018/04/12/autoreleasepool分析/</id>
    <published>2018-04-12T03:29:36.000Z</published>
    <updated>2018-05-20T14:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Autorelease pool implementation</span><br><span class="line">A thread's autorelease pool is a stack of pointers. </span><br><span class="line">Each pointer is either an object to <span class="keyword">release</span>, <span class="keyword">or</span> POOL_SENTINEL which <span class="keyword">is</span> </span><br><span class="line"> an autorelease pool boundary.</span><br><span class="line">A pool token <span class="keyword">is</span> a pointer <span class="keyword">to</span> the POOL_SENTINEL <span class="keyword">for</span> that pool. <span class="keyword">When</span> </span><br><span class="line"> the pool <span class="keyword">is</span> popped, every <span class="keyword">object</span> hotter <span class="keyword">than</span> the sentinel <span class="keyword">is</span> released.</span><br><span class="line">The stack <span class="keyword">is</span> divided <span class="keyword">into</span> a doubly-linked <span class="keyword">list</span> <span class="keyword">of</span> pages. Pages <span class="keyword">are</span> added </span><br><span class="line"> <span class="keyword">and</span> deleted <span class="keyword">as</span> necessary. </span><br><span class="line"><span class="keyword">Thread</span>-<span class="keyword">local</span> <span class="keyword">storage</span> points <span class="keyword">to</span> the hot page, <span class="keyword">where</span> newly autoreleased objects <span class="keyword">are</span> stored.</span><br></pre></td></tr></table></figure><p>翻译：<br>一个线程的自动释放池是一堆指针。指针要么是一个<code>release</code>对象，要么是一个<code>POOL_SENTINEL</code> — <code>POOL_SENTINEL</code>是一个自动回收池边界</p><p>一个<code>pool token</code>对于那个释放池来讲是一个指向<code>POOL_SENTINEL</code>(池子哨兵)的指针。当池子被释放时，每个比哨兵hotter的对象都要被释放–不是很懂。这个栈被划分为一系列双向列表，列表根据需要添加或者删除</p><p>TLS指针指向<code>hot page</code>，他就是最新的自动释放对对象存储的地方<br> <a id="more"></a> </p><p>反编译<code>main.m</code>文件之后的部分代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, <span class="built_in">NSStringFromClass</span>(((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在cpp文件中我们可以找到<code>__AtAutoreleasePool</code>的定义，他是一个结构体，在构造函数<code>__AtAutoreleasePool()</code>中调用了<code>objc_autoreleasePoolPush()</code>方法并返回了<code>atautoreleasepoolobj</code>这个释放池对象。在析构函数<code>~__AtAutoreleasePool()</code>中调用了<code>objc_autoreleasePoolPop()</code>方法</p><p>在这里我们可以想到，在main函数中当我们每声明一个<code>__AtAutoreleasePool</code>的时候,都会<br>调用构造函数<code>objc_autoreleasePoolPush</code> （因为他是结构体）向堆栈内压入一个释放池对象，而main执行完毕的时候会调用析构函数，这时候会用将压入的释放池释放，</p><p>所以</p><p>在<code>main</code>函数中大致是这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        <span class="comment">//创建自动释放池</span></span><br><span class="line">        __AtAutoreleasePool __autoreleasepool = objc_autoreleasePoolPush();</span><br><span class="line">        <span class="comment">//TODO 执行各种操作，将对象加入自动释放池</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放自动释放池</span></span><br><span class="line">        objc_autoreleasePoolPop(__autoreleasepool)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里我们就可以理解为什么我们需要自己使用<code>autorelasepool block</code>去处理一些代码，因为我们不能保证默认的<code>autoreleasepool</code>的释放周期，所以我们需要在小范围内进行<code>autorelease</code></p><h2 id="Push部分"><a href="#Push部分" class="headerlink" title="Push部分"></a>Push部分</h2><p>接下来，我们来看一下<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>方法，<a href="https://opensource.apple.com/source/objc4/objc4-532/runtime/NSObject.mm.auto.html" target="_blank" rel="noopener">在这里苹果官方的源码里</a>找到里对应的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rdar://9167170</span></span><br><span class="line">    <span class="keyword">if</span> (!ctxt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们能找到<code>AutoreleasePoolPage</code>才是实现的关键，那么我们接下来看看<code>AutoreleasePoolPage</code>的具体实现方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set this to 1 to mprotect() autorelease pool contents</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_AUTORELEASEPOOL 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SENTINEL 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">//用于数据校验</span></span><br><span class="line">    id *next; <span class="comment">//栈顶地址</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">//所在线程</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">//父page</span></span><br><span class="line">    AutoreleasePoolPage *child; <span class="comment">//子page</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth; <span class="comment">//深度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">protect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        mprotect(<span class="keyword">this</span>, SIZE, PROT_READ);</span><br><span class="line">        check();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>从代码里可以看出，他是一个典型的双向列表结构，每个<code>page</code>大小为<code>4096</code>Byte</p><p>接下来，我们来看下该类的push和pop函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PUSH</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hotPage()) &#123;</span><br><span class="line">            setHotPage(<span class="keyword">new</span> AutoreleasePoolPage(<span class="literal">NULL</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        id *dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">        assert(*dest == POOL_SENTINEL);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码里可以看到<code>POP()</code>函数中,<code>hotPage</code>是查找当前正在使用的<code>page</code>。第一次调用的时候hotPage为NULL,所以会新建一个<code>parent = NULL</code> 的 <code>AutoreleasePoolPage</code>对象，然后设置为<code>hotPage</code>实际上就是将TLS指针地址设置为该<code>page</code>地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">        tls_set_direct(key, (<span class="keyword">void</span> *)page); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后调用 <code>autoreleaseFast()</code>方法</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">  &#123;</span><br><span class="line">      AutoreleasePoolPage *<span class="built_in">page</span> = hotPage();</span><br><span class="line">      <span class="function"><span class="title">if</span> (<span class="built_in">page</span> &amp;&amp; !<span class="built_in">page</span>-&gt;</span>full()) &#123;</span><br><span class="line">          <span class="function"><span class="title">return</span> <span class="built_in">page</span>-&gt;</span>add(obj);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          return autoreleaseSlow(obj);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在方法中首先会获取先前设置的<code>hotPage</code>然后，判断这个<code>page</code>是否<code>full</code>如果存在<code>page</code>且没有满，则将对象添加到<code>page</code>中,也就是先前说到的<code>POOL_SENTINEL</code>哨兵对象。之后，返回对应的<code>page</code>。</p><p>这里的<code>add</code>方法实际上是将前的栈顶指针往下移动。</p><p>如果当前的<code>hotPage</code>已经满了,就会在这个双向列表的尾端再新增一个<code>page</code>,并将其设置为新的<code>hotPage</code></p><h2 id="Pop部分"><a href="#Pop部分" class="headerlink" title="Pop部分"></a>Pop部分</h2><p>下面的token就是push的返回值，也就是<code>POOL_SENTINEL</code>的地址，创建第一次使用NULL创建的，通过这个地址，<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POP</span></span><br><span class="line">static inline void pop(void *token) </span><br><span class="line">    &#123;</span><br><span class="line">        AutoreleasePoolPage *<span class="built_in">page</span>;</span><br><span class="line">        id *stop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            <span class="built_in">page</span> = pageForPointer(token); <span class="comment">//通过token找到对应page的地址</span></span><br><span class="line">            stop = (id *)token;</span><br><span class="line">            assert(*stop == POOL_SENTINEL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Token 0 is top-level pool</span></span><br><span class="line">            <span class="built_in">page</span> = coldPage();</span><br><span class="line">            assert(<span class="built_in">page</span>);</span><br><span class="line">            <span class="function"><span class="title">stop</span> = <span class="built_in">page</span>-&gt;</span>begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">releaseUntil</span>(stop); //对栈顶（<span class="built_in">page</span>-&gt;</span>next）到stop地址</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memory: delete empty children</span></span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if this page is more than half full</span></span><br><span class="line">        <span class="comment">// special case: delete everything for pop(0)</span></span><br><span class="line">        <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">            <span class="function"><span class="title">page</span>-&gt;</span>kill();</span><br><span class="line">            setHotPage(NULL);</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span>child) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;</span><br><span class="line">                <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill(); <span class="comment">//全部删除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>child) &#123;</span><br><span class="line">                <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();<span class="comment">//保留一个子page</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看处，<code>releaseUntil()</code>方法<code>pop</code>了从栈顶到哨兵对象的之间的所有对象（都调用了一遍<code>objc_release</code>方法）<br>注释中还写明:<br>若是<code>pop（0）</code>，则会清除所有的<code>page</code>对象。<br>若当前的<code>page</code>存放对象大于一半<code>page</code>时，将保留一个子<code>page</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>在大量创建临时变量的循环中，最好使用<code>autoreleaseblock</code>。这样在每次循环迭代中，只要block已结束，就会被release，减少内存占用。</li><li>自动释放池实际上是一个双向链表结构，每次创建一个自动释放池都会首先在栈顶压入以一个哨兵对象— POOL_SENTINEL。在源码中是这样定义的 <code>#define POOL_SENTINEL 0</code>。前面也提到他是作为一个<strong>自动回收池边界</strong>。</li><li>结合上面的描述，绘制了一个自动回收池的结构图，方便记忆<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq9pnllynjj30s70cr0tt.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Autorelease pool implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A thread&#39;s autorelease pool is a stack of pointers. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Each pointer is either an object to &lt;span class=&quot;keyword&quot;&gt;release&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; POOL_SENTINEL which &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; an autorelease pool boundary.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A pool token &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; a pointer &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; the POOL_SENTINEL &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; that pool. &lt;span class=&quot;keyword&quot;&gt;When&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; the pool &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; popped, every &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; hotter &lt;span class=&quot;keyword&quot;&gt;than&lt;/span&gt; the sentinel &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; released.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The stack &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; divided &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; a doubly-linked &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; pages. Pages &lt;span class=&quot;keyword&quot;&gt;are&lt;/span&gt; added &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; deleted &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; necessary. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Thread&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;storage&lt;/span&gt; points &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; the hot page, &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; newly autoreleased objects &lt;span class=&quot;keyword&quot;&gt;are&lt;/span&gt; stored.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译：&lt;br&gt;一个线程的自动释放池是一堆指针。指针要么是一个&lt;code&gt;release&lt;/code&gt;对象，要么是一个&lt;code&gt;POOL_SENTINEL&lt;/code&gt; — &lt;code&gt;POOL_SENTINEL&lt;/code&gt;是一个自动回收池边界&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;pool token&lt;/code&gt;对于那个释放池来讲是一个指向&lt;code&gt;POOL_SENTINEL&lt;/code&gt;(池子哨兵)的指针。当池子被释放时，每个比哨兵hotter的对象都要被释放–不是很懂。这个栈被划分为一系列双向列表，列表根据需要添加或者删除&lt;/p&gt;
&lt;p&gt;TLS指针指向&lt;code&gt;hot page&lt;/code&gt;，他就是最新的自动释放对对象存储的地方&lt;br&gt;
    
    </summary>
    
      <category term="ScourceCode" scheme="http://deeer.github.io/categories/ScourceCode/"/>
    
    
      <category term="autoreleasepool" scheme="http://deeer.github.io/tags/autoreleasepool/"/>
    
  </entry>
  
  <entry>
    <title>《白话区块链》读书笔记</title>
    <link href="http://deeer.github.io/2018/02/27/%E3%80%8A%E7%99%BD%E8%AF%9D%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://deeer.github.io/2018/02/27/《白话区块链》读书笔记/</id>
    <published>2018-02-27T15:23:18.000Z</published>
    <updated>2018-06-25T16:10:39.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>前言：</strong> 这本书用比较形象的例子阐述了区块链，并从中逐步引申出区块链中的相关概念。值得一读，推荐！</p></blockquote><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>区块链中的客户端，我们可以理解为各个用户的电子钱包</p><h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><p>在有些系统中，就考虑到被掷骰子投中的节点的劳动付出（即记账，然后向全体广播），毕竟整理数据、验证数据、打包数据、还要广而告之。于是设计出一种激励机制，负责打包数据的那个节点可以获得系统的奖励，这个奖励类似于论坛积分，站在软件技术的角度，就是一个数据。这个数据被视为<strong>奖金</strong>，大家会很积极去争取那个奖金，于是就希望骰子能投中自己，有些区块链系统在这个环节会设计出一种带有竞争的机制，让各个节点去抢，谁能抢到这个机会，谁就能获得大包数据的权利并同时获得这笔奖励，这种情况下，我们会很形象的将这个竞争过程称为<strong>挖坑</strong><br><a id="more"></a></p><h3 id="公钥私钥"><a href="#公钥私钥" class="headerlink" title="公钥私钥"></a>公钥私钥</h3><p>用公钥加密的数据必须使用对应的私钥来解密，而用私钥加密的（通常称为签名）的数据必须用对应的公钥来解密。公钥私钥的加密方式在区块链中称为<strong>脚本系统</strong></p><h3 id="真实性"><a href="#真实性" class="headerlink" title="真实性"></a>真实性</h3><p>区块链账本对每个区块都会计算出一个哈希值，称为区块哈希。通过区块哈希值来串连区块。这样的好处就是，如果有人篡改了中间的某个区块数据，那么后面的区块都要进行修改，这个时候并不是简单的修改一下后面区块的地址指向就能结束的，由于后面的区块是通过区块哈希来指向的，只要前面的区块发生了变化，这个区块哈希就无效了，就指不到正确的区块了</p><p>除了整个区块会被计算哈希外，区块中包含的每一笔事物数据也会被计算出一个哈希值，称为<strong>事物哈希</strong>。每个事物哈希都代表一个事物</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 这本书用比较形象的例子阐述了区块链，并从中逐步引申出区块链中的相关概念。值得一读，推荐！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;节点&quot;&gt;&lt;a href=&quot;#节点&quot; class=&quot;headerlink&quot; title=&quot;节点&quot;&gt;&lt;/a&gt;节点&lt;/h3&gt;&lt;p&gt;区块链中的客户端，我们可以理解为各个用户的电子钱包&lt;/p&gt;
&lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;p&gt;在有些系统中，就考虑到被掷骰子投中的节点的劳动付出（即记账，然后向全体广播），毕竟整理数据、验证数据、打包数据、还要广而告之。于是设计出一种激励机制，负责打包数据的那个节点可以获得系统的奖励，这个奖励类似于论坛积分，站在软件技术的角度，就是一个数据。这个数据被视为&lt;strong&gt;奖金&lt;/strong&gt;，大家会很积极去争取那个奖金，于是就希望骰子能投中自己，有些区块链系统在这个环节会设计出一种带有竞争的机制，让各个节点去抢，谁能抢到这个机会，谁就能获得大包数据的权利并同时获得这笔奖励，这种情况下，我们会很形象的将这个竞争过程称为&lt;strong&gt;挖坑&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Read" scheme="http://deeer.github.io/categories/Read/"/>
    
    
      <category term="BTC" scheme="http://deeer.github.io/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>整理说明</title>
    <link href="http://deeer.github.io/2018/02/27/%E6%95%B4%E7%90%86%E8%AF%B4%E6%98%8E/"/>
    <id>http://deeer.github.io/2018/02/27/整理说明/</id>
    <published>2018-02-27T14:30:13.000Z</published>
    <updated>2018-02-27T15:15:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！"><a href="#最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！" class="headerlink" title="最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！"></a>最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！&quot;&gt;&lt;a href=&quot;#最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！&quot; class=
      
    
    </summary>
    
    
      <category term="WARNING" scheme="http://deeer.github.io/tags/WARNING/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结</title>
    <link href="http://deeer.github.io/2017/12/10/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2017/12/10/2017年度总结/</id>
    <published>2017-12-10T05:42:33.000Z</published>
    <updated>2018-02-27T15:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一年过的好快，转眼又是一年。但是有时候又感觉好慢，才毕业一年，校园依旧是那么清晰可见。</p><h1 id="这一年。"><a href="#这一年。" class="headerlink" title="这一年。"></a>这一年。</h1><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>说真的，毕业一年生活真的不容易，倒不是因为钱，是因为心。毕业之后我才发现一个人的内心，一个人的sprit对于这个人是多么的重要，钱没有了可以再挣，但是失去内心的强大是什么都弥补不了的。恰好，我是个敏感的人。可能生活给予的烙印会在心里更加深刻些。也正因如此，或许我能在这些伤痛中体会到更加深刻的道理吧。有得有失，也是件好事。</p><p>一开始的我以为，物质的富足就是一切。相比同龄人，一开始我觉得我的物质需求已经不错了，然而不久之后，我发现我开始迷失了，我试图去寻找原因，开始四处寻找方法摆脱，直到有一天，我开始接受接受眼前的一切，随之心中的沸腾才慢慢平静下来。记得那天下午，许久不见的平静竟让我感到十分的欣喜。<br>这才是我想要的生活。一种学习驱动的生活。<br><a id="more"></a></p><h2 id="是的，我要走了"><a href="#是的，我要走了" class="headerlink" title="是的，我要走了"></a>是的，我要走了</h2><p>刚开始工作的我对眼前的一切都充满未知的新鲜感。但是在一个地方时间久了，就让我觉得无聊。虽然编程本身是件创造性的工作，但是做久了依旧觉得重复性太大，再加上上下班的劳累，就觉得好无聊啊。于是，我想，我还是离开吧。<br>这个决定其实对我来说并不是很容易，因为这意味着我将抛开现有的一切，无论是物质上还是精神上。当然物质是其次的，主要还是精神上，在一个团队呆久了，和整个团队经历的风风雨雨，一起发版，一起讨论，一起开发。大家都很好，真的，都很好。是我的问题，是我的问题。提交辞呈之后，我大概花了三四天时间才缓过来。天下没有不散的宴席。只是觉得对不起，因为每次有同事离开，我会觉得很难过，我不知道其他人怎么想，至少我是这样。相同的，我的离开也可能对团队造成影响，so sorry.</p><p>此处应该有图，但是怕放了我就写不下去了…<br>哎…愚蠢的地球人啊…<br>不破不立，大家有缘再见吧👋</p><p>这次离开也有个遗憾，原本我想创造一个充满学习氛围的团队。但是我失败了，原本的分享会，流产了。TL想组织订阅读书杂志，也没有继续执行。想讨论技术，但是似乎并没有人理会。最后我还是选择了沉默，没有选择的沉默。希望有人看到这里的话，能加紧建设这块吧🙏。学习氛围本应该是一个团队最吸引人的地方。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>回首去年的总结，说实话。预定指标完成的并不理想。这一年里心态的变化，花费了我很多时间。生活不止眼前的苟且，还有今后的苟且，时间会解决一切吧。总的来说，收获还是挺多的，也算是一种成长吧:]<br>对于未来，其实我并没有任何打算。这一年玩的差不多了，是时候出去开始踏上新的征程了！</p><p>To be continued … </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一年过的好快，转眼又是一年。但是有时候又感觉好慢，才毕业一年，校园依旧是那么清晰可见。&lt;/p&gt;
&lt;h1 id=&quot;这一年。&quot;&gt;&lt;a href=&quot;#这一年。&quot; class=&quot;headerlink&quot; title=&quot;这一年。&quot;&gt;&lt;/a&gt;这一年。&lt;/h1&gt;&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;p&gt;说真的，毕业一年生活真的不容易，倒不是因为钱，是因为心。毕业之后我才发现一个人的内心，一个人的sprit对于这个人是多么的重要，钱没有了可以再挣，但是失去内心的强大是什么都弥补不了的。恰好，我是个敏感的人。可能生活给予的烙印会在心里更加深刻些。也正因如此，或许我能在这些伤痛中体会到更加深刻的道理吧。有得有失，也是件好事。&lt;/p&gt;
&lt;p&gt;一开始的我以为，物质的富足就是一切。相比同龄人，一开始我觉得我的物质需求已经不错了，然而不久之后，我发现我开始迷失了，我试图去寻找原因，开始四处寻找方法摆脱，直到有一天，我开始接受接受眼前的一切，随之心中的沸腾才慢慢平静下来。记得那天下午，许久不见的平静竟让我感到十分的欣喜。&lt;br&gt;这才是我想要的生活。一种学习驱动的生活。&lt;br&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结及17年展望</title>
    <link href="http://deeer.github.io/2016/12/24/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2016/12/24/2016年度总结/</id>
    <published>2016-12-24T15:12:14.000Z</published>
    <updated>2018-02-27T15:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年发生了很多事，原本打算这次的年度总结会在星巴克里写，暖暖的空气，喝杯咖啡，望望窗外赶路的行人。计划往往赶不上变化。。。</p><h2 id="学生时代"><a href="#学生时代" class="headerlink" title="学生时代"></a>学生时代</h2><p>今年，完成了学校到社会的变迁，失去很多，收获的也很多，但无论怎样都是生命长河中的一部分。被时间赶着走，只能默默接受，习惯。现在的我还时常想起学生时代的样子，想想学生时代就这样结束了，总感觉空空的，我做了什么？？？</p><a id="more"></a><p>现在想想，学生时代的记忆里总会浮现出四个字：殊途同归。学习方面，我觉得我已经很努力了，很多时候总是扮演一个好学生的角色。但是事情总会发生意外，一个意外就可能导致很多意想不到的结果，我，只能硬着头皮继续走，因为这是我的人生，哪怕跌的再深，摔的再惨，也只能有我自己扛着，没有人能分担。所以我现在觉得是不是太乖了点，以至于现在的回忆中没有多少是令我印象深刻的地方，很多时候一味的听从父母的意思，反而抹杀了很多想法和可能性。当然，这在现在看来都是后话了，只能说如果从头再来的话，我应该不会那么乖。一方面，因为一路走来，遇到过很多很有想法的人，很有意思的人，他们的个性、态度绝不是一天两天就得到的，所以现在反而认为，淘气点也是个很好的优点。另一方面，从大学到步入社会以来，他们的想法和语言能力能让他们在社会和学校中成为佼佼者。</p><p>现在我也在不断的尝试改变一些固有的思路，用另一种态度，思维去看待一些东西。增加多方面的可能性，寻求另一种突破。</p><p>不过说起来，我也是个乖孩子的受益者，从大学的四六级，到现在的工作。我知道如何去梳理知识，如何从一个问题中发现其本质，然后试图找到问题的解决办法。所以多多少少也是种优势。</p><h2 id="步入社会"><a href="#步入社会" class="headerlink" title="步入社会"></a>步入社会</h2><p>今年，毕业了。从学校搬出来以后，发现外面的物价好贵，房价好贵，周围再也没有熟悉的同学了。一段时间里总是觉得空荡荡的，感觉失去了什么，心疼。在公司里呆久了，经历了很多人的入职、离职，一开始也是觉得不舍，不习惯，怎么突然就走了呢？一时间有些惴惴不安，四面楚歌，还好都过来了。现在面对同事离职，仍旧有些惋惜，但是多多少少淡定了些，大概这就是成长吧。看淡些就好了，事情总会发生，只是时间问题。</p><p>最近在看一部电视剧（很少看电视剧，但是那部剧的确反映了社会中的很多问题。很实际，很贴切）。剧里最让我印象深刻的是：远大的理想是买房，伟大的理想是买房。<br>虽然是14年的剧(主人公还在用黑莓),但是这句话放到现在对我来说还是很实际的。<br>以前没有想过这些问题，在这个阶段，愈发觉得很现实。颜值高的确有用，有车有房，的确有话语权，没车没房没颜值，loser不是你是谁？：]</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>作为一名程序员，技术浪潮滚滚向前，学习一直是第一生产力。比较开心的是，公司里的老猴子们都比较友善，大家都愿意教授自己的知识，这也是我比较看重的一点，融洽的气氛又有公司支持学习。希望今后的一段时间里能得到长足的进步，从各个方面提升自己的专业度。加油！！！</p><p>（互联网最大的特点就是消息发布的范围广，速度快。其说到这里不得不说一下马云，我对马云这人不是很了解，但是在他的一些演讲里，我觉得，其实马云的创业初期和大家都是一样的，都是什么赚钱就去做什么。唯一异于常人的一点就是马云当时学会了英语，然后看东西的角度和范围就不一样了，从一次次的创业失败中汲取教训，然后发现了一个商机并不断坚守，ok，他成功了。我认为他的成功很大程度上是依赖于互联网，他很想法，在互联网不是十分普及的时候就开始做。第一个吃螃蟹的人，首先占领了高地）</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>之前看到百度的一张搜索统计分析，发现的我搜素生活资料的次数接近于0，搜索技术问题的次数却很多。说实话，我认识到自己的缺陷，但是情商这种东西不是说要有就能有的，再加上平时最多的接触的还是代码，0或1的抉择十分明确。若有若无的东西是什么鬼？？<br>一定是BUG！很多时候真的觉得还是做个敲代码的小猴子就好，简简单单，买衣服花那么多时间还不如让我多学点技术问题，浪费时间。真想有个人能帮我选好衣服，我直接把钱转你好吗？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>技术展望</p><pre><code>新的一年希望能掌握的技术栈：1.JS／Node.js :目前也在学，对我来说新的东西嘛，到手的新东西总是比较的开心的，包括现在也有时间去学。个人认为，技术前景也不错。2.Swift:作为一名iOS开发居然还不怎么会用Swift简直说不过去3.Java: Java可以作为了解，慢慢深入。毕竟是比较大的一块东西。学起来也会是个缓慢的过程希望年底的时候再来看这个，能问心无愧的对自己说：都实现了！加油！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年发生了很多事，原本打算这次的年度总结会在星巴克里写，暖暖的空气，喝杯咖啡，望望窗外赶路的行人。计划往往赶不上变化。。。&lt;/p&gt;
&lt;h2 id=&quot;学生时代&quot;&gt;&lt;a href=&quot;#学生时代&quot; class=&quot;headerlink&quot; title=&quot;学生时代&quot;&gt;&lt;/a&gt;学生时代&lt;/h2&gt;&lt;p&gt;今年，完成了学校到社会的变迁，失去很多，收获的也很多，但无论怎样都是生命长河中的一部分。被时间赶着走，只能默默接受，习惯。现在的我还时常想起学生时代的样子，想想学生时代就这样结束了，总感觉空空的，我做了什么？？？&lt;/p&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>波浪效果实现</title>
    <link href="http://deeer.github.io/2016/03/17/%E6%B3%A2%E6%B5%AA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://deeer.github.io/2016/03/17/波浪效果实现/</id>
    <published>2016-03-17T14:45:53.000Z</published>
    <updated>2018-05-24T14:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中想添加一些动画，然后就想到了波浪的效果。<br>Google了一下大致，大致的方法就是用Quartz这个frameWork绘制</p><p>主要的核心代码<br><a id="more"></a></p><pre><code>-(void)drawRect:(CGRect)rect {  CGContextRef context = UIGraphicsGetCurrentContext();  CGMutablePathRef path = CGPathCreateMutable();  CGContextSetLineWidth(context, 1);  CGContextSetFillColorWithColor(context, [[UIColor purpleColor] CGColor]);  float y = basic_height;  CGPathMoveToPoint(path, NULL, 0, y);  //y = Asin(Bx+C)+D  //A：振幅 B：频率 C：左右偏移 D：相位for (float x= 0; x &lt;= rect.size.width; x++){     y = self.basicWaveNumber * sin(x/180.0*M_PI + 4 *self.RandonWaveNumber/M_PI) *5 +basic_height;  CGPathAddLineToPoint(path, nil, x, y);}  CGPathAddLineToPoint(path, nil, rect.size.width, rect.size.height);  CGPathAddLineToPoint(path, nil, 0, rect.size.height);  CGPathAddLineToPoint(path, nil, 0, basic_height);  CGContextAddPath(context, path);  CGContextFillPath(context);  CGContextDrawPath(context, kCGPathStroke);  CGPathRelease(path);}</code></pre><p>代码很简单，基本的思想上就是获取上下文，然后在每个像素上逐点描绘出波浪的形状，然后把各个点连起来。最后就是用定时器去每秒的刷新。</p><p>这里最为重要的一点就是在for循环中的“y = …” 这个公式。一开始简直就是一脸懵逼。然后慢慢挖掘，这居然是物理中的余弦公式（正弦公式也是一样的）。好吧，基本上已经还给老师了。高中以后那么多年。。哎</p><p>这里着重讲一下这个公式</p><blockquote><p>Y ＝ Asin(Bx + C)</p></blockquote><p>A: 振幅</p><p>B: 和频率相关,就是波动的快慢</p><p>C: 物理上讲叫相位，通俗的讲就是左右移动</p><p>基本上就是这样，我们要制作带有波动性的效果时，只要让B与C的值即可。</p><p><strong>但是</strong></p><p>总觉得这种方式的并不是最好的，0.02秒刷新一次，每次刷新还要执行一遍for循环。</p><p>so 尝试使用UIBezierPath与CALayer绘制，发现一个问题：之前使用贝塞尔绘制的曲线时都是一次，最多两次弯曲的曲线。像现在这这样多次连续弯曲的效果，一直没有遇到过。尝试使用- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;这个方法进行多个曲线的连续绘制，但是会在连接处出现不够平滑的现象，也就是说进行绘制的时候前一段的EndPoint与后一段startPoint没有任何连接性处理，所以出来的效果不能达到理想的平滑性</p><p>这个问题暂时没有解决，mark之。。。。<br>//TODO: to be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中想添加一些动画，然后就想到了波浪的效果。&lt;br&gt;Google了一下大致，大致的方法就是用Quartz这个frameWork绘制&lt;/p&gt;
&lt;p&gt;主要的核心代码&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://deeer.github.io/categories/iOS/"/>
    
    
      <category term="UIGraphics" scheme="http://deeer.github.io/tags/UIGraphics/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记之仿推特启动界面实现Demo</title>
    <link href="http://deeer.github.io/2016/01/03/%E4%BB%BF%E6%8E%A8%E7%89%B9%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0Demo/"/>
    <id>http://deeer.github.io/2016/01/03/仿推特启动界面实现Demo/</id>
    <published>2016-01-03T11:34:26.000Z</published>
    <updated>2018-03-03T12:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>前言</em></strong></p><p>今天要实现的是推特的启动界面的效果</p><p>类似于这样<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/twitterp.gif" alt="twitter0"><br><a id="more"></a></p><p>##首先<br>添加背景图片，之后在上面添加一层Layer作为遮罩。<br>这里的遮罩和PS中的遮罩效果大致相同。就是在上层layer的相应区域内才会出现下层区域的内容<br>效果如图<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/twittertwitter0.png" alt="twitter1"></p><p>很明显可以看出上层覆盖了一层星型的遮罩。</p><p>##第二步<br>实现遮罩的大小变化。<br>这里是使用CAKeyframeAnimtion 来实现<br>具体代码如下</p><pre><code>let transform = CAKeyframeAnimation(keyPath: &quot;bounds&quot;)    transform.delegate = self    transform.duration = 1    transform.beginTime = CACurrentMediaTime() + 1    let initalBounds = NSValue(CGRect:  CGRectMake(0, 0, 414, 763))    let secoundBounds = NSValue(CGRect: CGRectMake(0, 0, 50, 50))    let finalBounds = NSValue(CGRect:  CGRectMake(0, 0, 2000, 2000))    transform.values = [initalBounds,secoundBounds,finalBounds]    transform.keyTimes = [0 ,0.4,1]    transform.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut),CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)]    transform.removedOnCompletion = false    transform.fillMode = kCAFillModeForwards    masklayer.addAnimation(transform, forKey:&quot;maskAnimation&quot;)    UIView.animateWithDuration(0.25, delay: 1.3, options: UIViewAnimationOptions.TransitionNone, animations: { () -&gt; Void in        self.backgroundImageView!.transform = CGAffineTransformMakeScale(1.05, 1.05)        }) { (NilLiteralConvertible) -&gt; Void in       }</code></pre><p><strong><em>－－－插播－－－</em></strong></p><ol><li>CAKeyframeAnimtion 从名字中也能看出是就是<em>关键帧动画</em>的意思。这个概念和flash中的关键帧动物十分相似。我们在使用flash制作相关动画的时候，常常需要设置初始状态，结束状态，然后使用补间动画完成过渡。我们甚至能在动画运动的过程中指定任意位置的状态。在这的实现也是同样的，我们通过keyPath可以创建对应的动画类型。<em>注意:</em>这里的’bounds’并不是随意给出的。有关key对应的可选值有:bounds、position等类似这样的Animatable属性。我们设置了三种状态initalBounds、secoundBounds、finalBounds分别对应三个keyTime:[0 ,0.4,1]</li></ol><p>2.当在给一个CALyer添加动画的时候，动画并没有改变layer的实际属性，系统会创建一个原始layer的拷贝作为并在此基础上进行动画渲染。苹果将原始layer称为Model Layer，将拷贝的layer称为Presentation Layer.Presentation Layer会随动画的进度实时改变，而Model Layer不会</p><p>3.在动画结束后，系统会自动销毁Presentation Layer所以动画会回到初始的状态，所以这里要使用removedOnCompletion这个属性，而这个属性默认是true，所以我们将其设为false。这样就不会移除最后的效果了</p><p>4.有关的fillMode的相关介绍:该属性有四个枚举值，分别对应四种不同的情况</p><pre><code>kCAFillModeRemoved:动画结束后，将layer设置回初始的状态,动画开始和结束前对动画都没有影响kCAFillModeForwards:动画结束后保持动画最后的状态kCAFillModeBackwards:动画开始前，只要将动画加入layer，layer就处于动画的初始状态kCAFillModeBoth:动画加入后，立即处于初始状态，动画结束后，保持动画结束状态</code></pre><p><strong><em>－－－插播结束－－－</em></strong></p><p>#最后<br>为了能将动画效果衔接的更好，我们需要在遮罩和背景层之间添加一层动画</p><pre><code>let maskView = UIView()   maskView.frame = CGRectMake(0, 0, 414, 867)   maskView.backgroundColor = UIColor.whiteColor()   self.view.addSubview(maskView)   self.view.bringSubviewToFront(maskView)   UIView .animateWithDuration(0.1, delay: 1.35, options: UIViewAnimationOptions.CurveEaseIn, animations: { () -&gt; Void in       maskView.alpha = 0.0       }) { (NilLiteralConvertible) -&gt; Void in           maskView.removeFromSuperview()   }</code></pre><p><strong><em>实现完整代码:<a href="https://github.com/Deeer/twitterLunchrAnnimationDemo" target="_blank" rel="noopener">https://github.com/Deeer/twitterLunchrAnnimationDemo</a></em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天要实现的是推特的启动界面的效果&lt;/p&gt;
&lt;p&gt;类似于这样&lt;br&gt;&lt;img src=&quot;http://7xjg07.com1.z0.glb.clouddn.com/twitterp.gif&quot; alt=&quot;twitter0&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOSDemo" scheme="http://deeer.github.io/categories/iOSDemo/"/>
    
    
      <category term="Twitter　" scheme="http://deeer.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>2015年度总结</title>
    <link href="http://deeer.github.io/2015/12/31/2015%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2015/12/31/2015年度总结/</id>
    <published>2015-12-31T14:45:53.000Z</published>
    <updated>2018-02-27T15:18:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时光飞逝"><a href="#时光飞逝" class="headerlink" title="时光飞逝"></a>时光飞逝</h1><p>－－－记得上个年末时节，还在打算着用一年的时间来做一件事。但是一直想不到去做些什么。但是想不到后来会忙成这样。大四的上半学期，也就是15年的年末，开始走出校园，走向社会开始工作。又是一个新的开始的，新的起点，新的环境。在我投身工作的几个月里，时间真的非常快。每天都会有问题，每天都在想着尝试着解决问题。每天的最不爽的就是早上上班时候，说实话，睡眠时间真不够，有时甚至为了赶进度一天要工作近21个小时。3个小时的睡眠时间是个奢侈的享受。没办法，第二天还要工作，还是稍微会睡儿。在公交上也容易睡着，迷迷糊糊到公司，结果我还是第一个到的。公司离学校也不远，但是强迫症总觉得迟到不好，也许是在校时培养的习惯吧。所以一半都会提前半个小时到公司，只可惜电脑反应实在太慢，开机要好久。。。心好累😂。现在还只是一只小猴子，也算是初步走上了自己预想的轨迹吧。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>－－－大学生涯也就快过去了。从大一时陌生尴尬，到大四的“劳燕分飞”，整个过程是十分微妙的。感觉我的大学都没做什么就过去了，好快！！日子一天天的过，想想也有三年多了呢。现在是最后的尾巴了，所有过去发生的种种现在感觉都已经无所谓了。大家都是同学一场，也不容易。</p><p>突然发现整个似乎大学都是从“大家同学一场”开始，又是从“大家同学一场”结束的。也不用刻意追去什么，大家各自安好，才是真的好</p><hr><p>－－－新的一年，新的开始，今年的主题是REVERSE。希望能在接下来一年的时间里做些颠覆性的东西，尝试下不一样的选择。改变现在的生活状况，思维方式，让生活变的更加多彩！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时光飞逝&quot;&gt;&lt;a href=&quot;#时光飞逝&quot; class=&quot;headerlink&quot; title=&quot;时光飞逝&quot;&gt;&lt;/a&gt;时光飞逝&lt;/h1&gt;&lt;p&gt;－－－记得上个年末时节，还在打算着用一年的时间来做一件事。但是一直想不到去做些什么。但是想不到后来会忙成这样。大四的上半学期，也就是15年的年末，开始走出校园，走向社会开始工作。又是一个新的开始的，新的起点，新的环境。在我投身工作的几个月里，时间真的非常快。每天都会有问题，每天都在想着尝试着解决问题。每天的最不爽的就是早上上班时候，说实话，睡眠时间真不够，有时甚至为了赶进度一天要工作近21个小时。3个小时的睡眠时间是个奢侈的享受。没办法，第二天还要工作，还是稍微会睡儿。在公交上也容易睡着，迷迷糊糊到公司，结果我还是第一个到的。公司离学校也不远，但是强迫症总觉得迟到不好，也许是在校时培养的习惯吧。所以一半都会提前半个小时到公司，只可惜电脑反应实在太慢，开机要好久。。。心好累😂。现在还只是一只小猴子，也算是初步走上了自己预想的轨迹吧。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITableViewCell自适应高度（iOS8）</title>
    <link href="http://deeer.github.io/2015/09/27/UITableViewCell%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6Demo/"/>
    <id>http://deeer.github.io/2015/09/27/UITableViewCell自适应高度Demo/</id>
    <published>2015-09-27T05:55:05.000Z</published>
    <updated>2018-03-03T12:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目时遇到个cell的高度自适应问题,大致的需求是这样子的<br><br></p><p><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeIMG_0006.jpg" alt="Cell自适应"></p><p>cell中主要有三块区域分别对应三个label。并且三个label的y值是相同的。每个label之间的文字都有一定的距离，使得每块区域都有一个很好的划分。</p><a id="more"></a><p><br></p><p>#iOS8－－self Sizing Cells</p><p>开始没找到好的解决办法。字数一多也会出现一些问题。<br>今天特地好好整理了一下</p><p>发现在iOS8以后计算高度可以使用self Sizing Cells来对高度进行处理。<br>但是我们需要注意的:<br><br></p><p>1.cell重点内容必须有相应的约束－－网上看到一些使用Auto Layout来进行约束的。我这里是使用Masonry<br><br></p><p>2.设置tableview的estimatedRowHeight，或者设置cell的estimatedRowHeight高度。两者中任选其一即可，但是千万不能没有<br><br></p><p>3.设置tabelVeiw的rowHeight属性为UITableViewAutomaticDimension。<br><br></p><p>即在viewDidload中添加</p><pre><code>//cell用Masonry布局好后，添加这两句即可self.tableView.estimatedRowHeight = 44.0f;self.tableView.rowHeight = UITableViewAutomaticDimension;</code></pre><p>实现以上三步，我们就不用去处理与高度相相关的代理方法了</p><p>#注意</p><p>我们在用masonry进行自动布局的时候，如果cell中各个label文字没有对齐。即这种效果<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午2.42.30.png" alt="Cell自适应wrong2"></p><p>这里就是Masonry布局的问题了<br>下面我们为detailLbl添加bottom的offset值。</p><pre><code>- (void)createFrame {[self.nameLbl mas_makeConstraints:^(MASConstraintMaker *make) {make.left.equalTo(self.contentView).offset(15);make.top.equalTo(self.contentView).offset(15);make.width.lessThanOrEqualTo(@60);}];[self.detailLbl mas_makeConstraints:^(MASConstraintMaker *make) {   make.left.equalTo(self.contentView).offset(90);make.top.equalTo(self.contentView).offset(15);make.right.equalTo(self.contentView).offset(-65);//添加这句make.bottom.equalTo(self.contentView).offset(-10);}];[self.timeLbl mas_makeConstraints:^(MASConstraintMaker *make) {make.right.equalTo(self.contentView).offset(-15);make.top.equalTo(self.contentView).offset(15);make.width.lessThanOrEqualTo(@50);}];}</code></pre><p>这样无论文字多少，中间的文字适中距离底部都为10</p><p><br><br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午3.11.26.png" alt="CellFinal1"><br><br></p><p>效果不错的样子呢！！(^O^)<br>但是代码中暴露出又一个问题，左侧nameLbl文字一对会又会出现bug<br>什么鬼！！<br>于是又一次陷入了沉思中。。。<br><br><br><img src="http://7xjg07.com1.z0.glb.clouddn.com/Deedee.jpg" alt="InsertCPic"><br><br></p><p>翻翻文档又想出了一个好办法 －－不绑定bottom的边距，改为height设定最大值</p><pre><code>- (void)createFrame{    [self.nameLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.contentView).offset(15);    make.top.equalTo(self.contentView).offset(15);    make.width.lessThanOrEqualTo(@60);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];    [self.detailLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.contentView).offset(90);    make.top.equalTo(self.contentView).offset(15);    make.right.equalTo(self.contentView).offset(-65);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];    [self.timeLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.right.equalTo(self.contentView).offset(-15);    make.top.equalTo(self.contentView).offset(15);    make.width.lessThanOrEqualTo(@50);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];}</code></pre><p>这样这样才是我们需要的最终结果呢！！^_^<br>哪怕字再多也不是问题了<br>如图<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午3.27.37.png" alt="cellFinal"><br>好吧。。图是有点丑，但是这样才是比较极端的情况<br><br></p><p>如果有什么不对，或者有更好的解决方法，还望指出，万分感谢😀<br>以下是完整项目链接<a href="https://github.com/Deeer/DeeLearning" target="_blank" rel="noopener">https://github.com/Deeer/DeeLearning</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做项目时遇到个cell的高度自适应问题,大致的需求是这样子的&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xjg07.com1.z0.glb.clouddn.com/DeeIMG_0006.jpg&quot; alt=&quot;Cell自适应&quot;&gt;&lt;/p&gt;
&lt;p&gt;cell中主要有三块区域分别对应三个label。并且三个label的y值是相同的。每个label之间的文字都有一定的距离，使得每块区域都有一个很好的划分。&lt;/p&gt;
    
    </summary>
    
      <category term="iOSDemo" scheme="http://deeer.github.io/categories/iOSDemo/"/>
    
    
      <category term="UITabelViewCell" scheme="http://deeer.github.io/tags/UITabelViewCell/"/>
    
  </entry>
  
  <entry>
    <title>new</title>
    <link href="http://deeer.github.io/2015/06/01/new/"/>
    <id>http://deeer.github.io/2015/06/01/new/</id>
    <published>2015-05-31T18:26:59.000Z</published>
    <updated>2018-02-27T14:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>记于：2015年6月1日凌晨2：30. 自己做的第一个博客，六一快乐！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记于：2015年6月1日凌晨2：30. 自己做的第一个博客，六一快乐！！！&lt;/p&gt;

      
    
    </summary>
    
      <category term="LIFE" scheme="http://deeer.github.io/categories/LIFE/"/>
    
    
      <category term="LIFE" scheme="http://deeer.github.io/tags/LIFE/"/>
    
  </entry>
  
</feed>
