<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dee+&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9ec463cf5332e6bd2a44e71301afafd3</icon>
  <subtitle>士不可以不弘毅，任重而道远。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://deeer.github.io/"/>
  <updated>2018-04-12T05:41:42.000Z</updated>
  <id>http://deeer.github.io/</id>
  
  <author>
    <name>Deeer</name>
    <email>dee_code@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>autoreleasepool分析</title>
    <link href="http://deeer.github.io/2018/04/12/autoreleasepool%E5%88%86%E6%9E%90/"/>
    <id>http://deeer.github.io/2018/04/12/autoreleasepool分析/</id>
    <published>2018-04-12T03:29:36.000Z</published>
    <updated>2018-04-12T05:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Autorelease pool implementation</span><br><span class="line">A thread's autorelease pool is a stack of pointers. </span><br><span class="line">Each pointer is either an object to <span class="keyword">release</span>, <span class="keyword">or</span> POOL_SENTINEL which <span class="keyword">is</span> </span><br><span class="line"> an autorelease pool boundary.</span><br><span class="line">A pool token <span class="keyword">is</span> a pointer <span class="keyword">to</span> the POOL_SENTINEL <span class="keyword">for</span> that pool. <span class="keyword">When</span> </span><br><span class="line"> the pool <span class="keyword">is</span> popped, every <span class="keyword">object</span> hotter <span class="keyword">than</span> the sentinel <span class="keyword">is</span> released.</span><br><span class="line">The stack <span class="keyword">is</span> divided <span class="keyword">into</span> a doubly-linked <span class="keyword">list</span> <span class="keyword">of</span> pages. Pages <span class="keyword">are</span> added </span><br><span class="line"> <span class="keyword">and</span> deleted <span class="keyword">as</span> necessary. </span><br><span class="line"><span class="keyword">Thread</span>-<span class="keyword">local</span> <span class="keyword">storage</span> points <span class="keyword">to</span> the hot page, <span class="keyword">where</span> newly autoreleased objects <span class="keyword">are</span> stored.</span><br></pre></td></tr></table></figure><p>翻译：<br>一个线程的自动释放池是一堆指针。指针要么是一个<code>release</code>对象，要么是一个<code>POOL_SENTINEL</code> — <code>POOL_SENTINEL</code>是一个自动回收池边界</p><p>一个<code>pool token</code>对于那个释放池来讲是一个指向<code>POOL_SENTINEL</code>(池子哨兵)的指针。当池子被释放时，没个比哨兵hotter的对象都要被释放–不是很懂。这个栈被划分为一系列双向列表，列表根据需要添加或者删除</p><p>TLS指证指向<code>hot page</code>，他就是最新的自动释放对对象存储的地方<br> <a id="more"></a> </p><p>反编译<code>main.m</code>文件之后的部分代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, <span class="built_in">NSStringFromClass</span>(((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在cpp文件中我们可以找到<code>__AtAutoreleasePool</code>的定义，他是一个结构体，在构造函数<code>__AtAutoreleasePool()</code>中调用了<code>objc_autoreleasePoolPush()</code>方法并返回了<code>atautoreleasepoolobj</code>这个释放池对象。在析构函数<code>~__AtAutoreleasePool()</code>中调用了<code>objc_autoreleasePoolPop()</code>方法</p><p>在这里我们可以想到，在main函数中当我们每声明一个<code>__AtAutoreleasePool</code>的时候,都会<br>调用构造函数<code>objc_autoreleasePoolPush</code> （因为他是结构体）向堆栈内压入一个释放池对象，而main执行完毕的时候会调用析构函数，这时候会用将压入的释放池释放，</p><p>所以</p><p>在<code>main</code>函数中大致是这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        <span class="comment">//创建自动释放池</span></span><br><span class="line">        __AtAutoreleasePool __autoreleasepool = objc_autoreleasePoolPush();</span><br><span class="line">        <span class="comment">//TODO 执行各种操作，将对象加入自动释放池</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放自动释放池</span></span><br><span class="line">        objc_autoreleasePoolPop(__autoreleasepool)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里我们就可以理解为什么我们需要自己使用<code>autorelasepool block</code>去处理一些代码，因为我们不能保证默认的<code>autoreleasepool</code>的释放周期，所以我们需要在小范围内进行<code>autorelease</code></p><h2 id="Push部分"><a href="#Push部分" class="headerlink" title="Push部分"></a>Push部分</h2><p>接下来，我们来看一下<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>方法，<a href="https://opensource.apple.com/source/objc4/objc4-532/runtime/NSObject.mm.auto.html" target="_blank" rel="noopener">在这里苹果官方的源码里</a>找到里对应的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rdar://9167170</span></span><br><span class="line">    <span class="keyword">if</span> (!ctxt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们能找到<code>AutoreleasePoolPage</code>才是实现的关键，那么我们接下来看看<code>AutoreleasePoolPage</code>的具体实现方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set this to 1 to mprotect() autorelease pool contents</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_AUTORELEASEPOOL 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SENTINEL 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">//用于数据校验</span></span><br><span class="line">    id *next; <span class="comment">//栈顶地址</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">//所在线程</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">//父page</span></span><br><span class="line">    AutoreleasePoolPage *child; <span class="comment">//子page</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth; <span class="comment">//深度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">protect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        mprotect(<span class="keyword">this</span>, SIZE, PROT_READ);</span><br><span class="line">        check();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>从代码里可以看出，他是一个典型的双向列表结构，没个<code>page</code>大小为<code>4096</code>Byte</p><p>接下来，我们来看下该类的push和pop函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PUSH</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hotPage()) &#123;</span><br><span class="line">            setHotPage(<span class="keyword">new</span> AutoreleasePoolPage(<span class="literal">NULL</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        id *dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">        assert(*dest == POOL_SENTINEL);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码里可以看到<code>POP()</code>函数中,<code>hotPage</code>是查找当前正在使用的<code>page</code>。第一次调用的时候hotPage为NULL,所以会新建一个<code>parent = NULL</code> 的 <code>AutoreleasePoolPage</code>对象，然后设置为<code>hotPage</code>实际上就是将TLS指针地址设置为该<code>page</code>地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">        tls_set_direct(key, (<span class="keyword">void</span> *)page); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后调用 <code>autoreleaseFast()</code>方法</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">  &#123;</span><br><span class="line">      AutoreleasePoolPage *<span class="built_in">page</span> = hotPage();</span><br><span class="line">      <span class="function"><span class="title">if</span> (<span class="built_in">page</span> &amp;&amp; !<span class="built_in">page</span>-&gt;</span>full()) &#123;</span><br><span class="line">          <span class="function"><span class="title">return</span> <span class="built_in">page</span>-&gt;</span>add(obj);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          return autoreleaseSlow(obj);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在方法中首先会获取先前设置的<code>hotPage</code>然后，判断这个<code>page</code>是否<code>full</code>如果存在<code>page</code>且没有满，则将对象添加到<code>page</code>中,也就是先前说到的<code>POOL_SENTINEL</code>哨兵对象。之后，返回对应的<code>page</code>。</p><p>这里的<code>add</code>方法实际上是将前的栈顶指针往下移动。</p><p>如果当前的<code>hotPage</code>已经满了,就会在这个双向列表的尾端再新增一个<code>page</code>,并将其设置为新的<code>hotPage</code></p><h2 id="Pop部分"><a href="#Pop部分" class="headerlink" title="Pop部分"></a>Pop部分</h2><p>下面的token就是push的返回值，也就是<code>POOL_SENTINEL</code>的地址，创建第一次使用NULL创建的，通过这个地址，<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POP</span></span><br><span class="line">static inline void pop(void *token) </span><br><span class="line">    &#123;</span><br><span class="line">        AutoreleasePoolPage *<span class="built_in">page</span>;</span><br><span class="line">        id *stop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            <span class="built_in">page</span> = pageForPointer(token); <span class="comment">//通过token找到对应page的地址</span></span><br><span class="line">            stop = (id *)token;</span><br><span class="line">            assert(*stop == POOL_SENTINEL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Token 0 is top-level pool</span></span><br><span class="line">            <span class="built_in">page</span> = coldPage();</span><br><span class="line">            assert(<span class="built_in">page</span>);</span><br><span class="line">            <span class="function"><span class="title">stop</span> = <span class="built_in">page</span>-&gt;</span>begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">releaseUntil</span>(stop); //对栈顶（<span class="built_in">page</span>-&gt;</span>next）到stop地址</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memory: delete empty children</span></span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if this page is more than half full</span></span><br><span class="line">        <span class="comment">// special case: delete everything for pop(0)</span></span><br><span class="line">        <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">            <span class="function"><span class="title">page</span>-&gt;</span>kill();</span><br><span class="line">            setHotPage(NULL);</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span>child) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (<span class="built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;</span><br><span class="line">                <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill(); <span class="comment">//全部删除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span> (<span class="built_in">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>child) &#123;</span><br><span class="line">                <span class="function"><span class="title">page</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span><span class="function"><span class="title">child</span>-&gt;</span>kill();<span class="comment">//保留一个子page</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看处，<code>releaseUntil()</code>方法<code>pop</code>了从栈顶到哨兵对象的之间的所有对象（都调用了一遍<code>objc_release</code>方法）<br>注释中还写明:<br>若是<code>pop（0）</code>，则会清除所有的<code>page</code>对象。<br>若当前的<code>page</code>存放对象大于一半<code>page</code>时，将保留一个子<code>page</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>在大量创建临时变量的循环中，最好使用<code>autoreleaseblock</code>。这样在每次循环迭代中，只要block已结束，就会被release，减少内存占用。</li><li>自动释放池实际上是一个双向链表结构，每次创建一个自动释放池都会首先在栈顶压入以一个哨兵对象— POOL_SENTINEL。在源码中是这样定义的 <code>#define POOL_SENTINEL 0</code>。前面也提到他是作为一个<strong>自动回收池边界</strong>。</li><li>结合上面的描述，绘制了一个自动回收池的结构图，方便记忆<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq9pnllynjj30s70cr0tt.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Autorelease pool implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A thread&#39;s autorelease pool is a stack of pointers. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Each pointer is either an object to &lt;span class=&quot;keyword&quot;&gt;release&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; POOL_SENTINEL which &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; an autorelease pool boundary.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A pool token &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; a pointer &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; the POOL_SENTINEL &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; that pool. &lt;span class=&quot;keyword&quot;&gt;When&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; the pool &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; popped, every &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; hotter &lt;span class=&quot;keyword&quot;&gt;than&lt;/span&gt; the sentinel &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; released.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The stack &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; divided &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; a doubly-linked &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; pages. Pages &lt;span class=&quot;keyword&quot;&gt;are&lt;/span&gt; added &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; deleted &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; necessary. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Thread&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;storage&lt;/span&gt; points &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; the hot page, &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; newly autoreleased objects &lt;span class=&quot;keyword&quot;&gt;are&lt;/span&gt; stored.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译：&lt;br&gt;一个线程的自动释放池是一堆指针。指针要么是一个&lt;code&gt;release&lt;/code&gt;对象，要么是一个&lt;code&gt;POOL_SENTINEL&lt;/code&gt; — &lt;code&gt;POOL_SENTINEL&lt;/code&gt;是一个自动回收池边界&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;pool token&lt;/code&gt;对于那个释放池来讲是一个指向&lt;code&gt;POOL_SENTINEL&lt;/code&gt;(池子哨兵)的指针。当池子被释放时，没个比哨兵hotter的对象都要被释放–不是很懂。这个栈被划分为一系列双向列表，列表根据需要添加或者删除&lt;/p&gt;
&lt;p&gt;TLS指证指向&lt;code&gt;hot page&lt;/code&gt;，他就是最新的自动释放对对象存储的地方&lt;br&gt;
    
    </summary>
    
      <category term="ScourceCode" scheme="http://deeer.github.io/categories/ScourceCode/"/>
    
    
      <category term="autoreleasepool" scheme="http://deeer.github.io/tags/autoreleasepool/"/>
    
  </entry>
  
  <entry>
    <title>《白话区块链》读书笔记</title>
    <link href="http://deeer.github.io/2018/02/27/%E3%80%8A%E7%99%BD%E8%AF%9D%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://deeer.github.io/2018/02/27/《白话区块链》读书笔记/</id>
    <published>2018-02-27T15:23:18.000Z</published>
    <updated>2018-02-27T15:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>前言：</strong> 这本书用比较形象的例子阐述了区块链，并从中逐步引申出区块链中的相关概念。值得一读，推荐！</p></blockquote><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>区块链中的客户端，我们可以理解为各个用户的电子钱包</p><h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><p>在有些系统中，就考虑到被掷骰子投中的节点的劳动付出（即记账，然后向全体广播），毕竟整理数据、验证数据、打包数据、还要广而告之。于是设计出一种激励机制，负责打包数据的那个节点可以获得系统的奖励，这个奖励类似于论坛积分，站在软件技术的角度，就是一个数据。这个数据被视为<strong>奖金</strong>，大家会很积极去争取那个奖金，于是就希望骰子能投中自己，有些区块链系统在这个环节会设计出一种带有竞争的机制，让各个节点去抢，谁能抢到这个机会，谁就能获得大包数据的权利并同时获得这笔奖励，这种情况下，我们会很形象的将这个竞争过程称为<strong>挖坑</strong><br><a id="more"></a></p><h3 id="公钥私钥"><a href="#公钥私钥" class="headerlink" title="公钥私钥"></a>公钥私钥</h3><p>用公钥加密的数据必须使用对应的私钥来解密，而用私钥加密的（通常称为签名）的数据必须用对应的公钥来解密。公钥私钥的加密方式在区块链中称为<strong>脚本系统</strong></p><h3 id="真实性"><a href="#真实性" class="headerlink" title="真实性"></a>真实性</h3><p>区块链账本对每个区块都会计算出一个哈希值，称为区块哈希。通过区块哈希值来串连区块。这样的好处就是，如果有人篡改了中间的某个区块数据，那么后面的区块都要进行修改，这个时候并不是简单的修改一下后面区块的地址指向就能结束的，由于后面的区块是通过区块哈希来指向的，只要前面的区块发生了变化，这个区块哈希就无效了，就指不到正确的区块了</p><p>除了整个区块会被计算哈希外，区块中包含的每一笔事物数据也会被计算出一个哈希值，称为<strong>事物哈希</strong>。每个事物哈希都代表一个事物</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 这本书用比较形象的例子阐述了区块链，并从中逐步引申出区块链中的相关概念。值得一读，推荐！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;节点&quot;&gt;&lt;a href=&quot;#节点&quot; class=&quot;headerlink&quot; title=&quot;节点&quot;&gt;&lt;/a&gt;节点&lt;/h3&gt;&lt;p&gt;区块链中的客户端，我们可以理解为各个用户的电子钱包&lt;/p&gt;
&lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;p&gt;在有些系统中，就考虑到被掷骰子投中的节点的劳动付出（即记账，然后向全体广播），毕竟整理数据、验证数据、打包数据、还要广而告之。于是设计出一种激励机制，负责打包数据的那个节点可以获得系统的奖励，这个奖励类似于论坛积分，站在软件技术的角度，就是一个数据。这个数据被视为&lt;strong&gt;奖金&lt;/strong&gt;，大家会很积极去争取那个奖金，于是就希望骰子能投中自己，有些区块链系统在这个环节会设计出一种带有竞争的机制，让各个节点去抢，谁能抢到这个机会，谁就能获得大包数据的权利并同时获得这笔奖励，这种情况下，我们会很形象的将这个竞争过程称为&lt;strong&gt;挖坑&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://deeer.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="BTC" scheme="http://deeer.github.io/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>整理说明</title>
    <link href="http://deeer.github.io/2018/02/27/%E6%95%B4%E7%90%86%E8%AF%B4%E6%98%8E/"/>
    <id>http://deeer.github.io/2018/02/27/整理说明/</id>
    <published>2018-02-27T14:30:13.000Z</published>
    <updated>2018-02-27T15:15:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！"><a href="#最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！" class="headerlink" title="最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！"></a>最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！&quot;&gt;&lt;a href=&quot;#最近发现播客格式存在一些问题，包括最近也有些想整理博客的想法，所以将之前的所有博客撤下，重新整理归集，温故知新！&quot; class=
      
    
    </summary>
    
    
      <category term="WARNING" scheme="http://deeer.github.io/tags/WARNING/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结</title>
    <link href="http://deeer.github.io/2017/12/10/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2017/12/10/2017年度总结/</id>
    <published>2017-12-10T05:42:33.000Z</published>
    <updated>2018-02-27T15:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一年过的好快，转眼又是一年。但是有时候又感觉好慢，才毕业一年，校园依旧是那么清晰可见。</p><h1 id="这一年。"><a href="#这一年。" class="headerlink" title="这一年。"></a>这一年。</h1><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>说真的，毕业一年生活真的不容易，倒不是因为钱，是因为心。毕业之后我才发现一个人的内心，一个人的sprit对于这个人是多么的重要，钱没有了可以再挣，但是失去内心的强大是什么都弥补不了的。恰好，我是个敏感的人。可能生活给予的烙印会在心里更加深刻些。也正因如此，或许我能在这些伤痛中体会到更加深刻的道理吧。有得有失，也是件好事。</p><p>一开始的我以为，物质的富足就是一切。相比同龄人，一开始我觉得我的物质需求已经不错了，然而不久之后，我发现我开始迷失了，我试图去寻找原因，开始四处寻找方法摆脱，直到有一天，我开始接受接受眼前的一切，随之心中的沸腾才慢慢平静下来。记得那天下午，许久不见的平静竟让我感到十分的欣喜。<br>这才是我想要的生活。一种学习驱动的生活。<br><a id="more"></a></p><h2 id="是的，我要走了"><a href="#是的，我要走了" class="headerlink" title="是的，我要走了"></a>是的，我要走了</h2><p>刚开始工作的我对眼前的一切都充满未知的新鲜感。但是在一个地方时间久了，就让我觉得无聊。虽然编程本身是件创造性的工作，但是做久了依旧觉得重复性太大，再加上上下班的劳累，就觉得好无聊啊。于是，我想，我还是离开吧。<br>这个决定其实对我来说并不是很容易，因为这意味着我将抛开现有的一切，无论是物质上还是精神上。当然物质是其次的，主要还是精神上，在一个团队呆久了，和整个团队经历的风风雨雨，一起发版，一起讨论，一起开发。大家都很好，真的，都很好。是我的问题，是我的问题。提交辞呈之后，我大概花了三四天时间才缓过来。天下没有不散的宴席。只是觉得对不起，因为每次有同事离开，我会觉得很难过，我不知道其他人怎么想，至少我是这样。相同的，我的离开也可能对团队造成影响，so sorry.</p><p>此处应该有图，但是怕放了我就写不下去了…<br>哎…愚蠢的地球人啊…<br>不破不立，大家有缘再见吧👋</p><p>这次离开也有个遗憾，原本我想创造一个充满学习氛围的团队。但是我失败了，原本的分享会，流产了。TL想组织订阅读书杂志，也没有继续执行。想讨论技术，但是似乎并没有人理会。最后我还是选择了沉默，没有选择的沉默。希望有人看到这里的话，能加紧建设这块吧🙏。学习氛围本应该是一个团队最吸引人的地方。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>回首去年的总结，说实话。预定指标完成的并不理想。这一年里心态的变化，花费了我很多时间。生活不止眼前的苟且，还有今后的苟且，时间会解决一切吧。总的来说，收获还是挺多的，也算是一种成长吧:]<br>对于未来，其实我并没有任何打算。这一年玩的差不多了，是时候出去开始踏上新的征程了！</p><p>To be continued … </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一年过的好快，转眼又是一年。但是有时候又感觉好慢，才毕业一年，校园依旧是那么清晰可见。&lt;/p&gt;
&lt;h1 id=&quot;这一年。&quot;&gt;&lt;a href=&quot;#这一年。&quot; class=&quot;headerlink&quot; title=&quot;这一年。&quot;&gt;&lt;/a&gt;这一年。&lt;/h1&gt;&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;p&gt;说真的，毕业一年生活真的不容易，倒不是因为钱，是因为心。毕业之后我才发现一个人的内心，一个人的sprit对于这个人是多么的重要，钱没有了可以再挣，但是失去内心的强大是什么都弥补不了的。恰好，我是个敏感的人。可能生活给予的烙印会在心里更加深刻些。也正因如此，或许我能在这些伤痛中体会到更加深刻的道理吧。有得有失，也是件好事。&lt;/p&gt;
&lt;p&gt;一开始的我以为，物质的富足就是一切。相比同龄人，一开始我觉得我的物质需求已经不错了，然而不久之后，我发现我开始迷失了，我试图去寻找原因，开始四处寻找方法摆脱，直到有一天，我开始接受接受眼前的一切，随之心中的沸腾才慢慢平静下来。记得那天下午，许久不见的平静竟让我感到十分的欣喜。&lt;br&gt;这才是我想要的生活。一种学习驱动的生活。&lt;br&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结及17年展望</title>
    <link href="http://deeer.github.io/2016/12/24/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2016/12/24/2016年度总结/</id>
    <published>2016-12-24T15:12:14.000Z</published>
    <updated>2018-02-27T15:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年发生了很多事，原本打算这次的年度总结会在星巴克里写，暖暖的空气，喝杯咖啡，望望窗外赶路的行人。计划往往赶不上变化。。。</p><h2 id="学生时代"><a href="#学生时代" class="headerlink" title="学生时代"></a>学生时代</h2><p>今年，完成了学校到社会的变迁，失去很多，收获的也很多，但无论怎样都是生命长河中的一部分。被时间赶着走，只能默默接受，习惯。现在的我还时常想起学生时代的样子，想想学生时代就这样结束了，总感觉空空的，我做了什么？？？</p><a id="more"></a><p>现在想想，学生时代的记忆里总会浮现出四个字：殊途同归。学习方面，我觉得我已经很努力了，很多时候总是扮演一个好学生的角色。但是事情总会发生意外，一个意外就可能导致很多意想不到的结果，我，只能硬着头皮继续走，因为这是我的人生，哪怕跌的再深，摔的再惨，也只能有我自己扛着，没有人能分担。所以我现在觉得是不是太乖了点，以至于现在的回忆中没有多少是令我印象深刻的地方，很多时候一味的听从父母的意思，反而抹杀了很多想法和可能性。当然，这在现在看来都是后话了，只能说如果从头再来的话，我应该不会那么乖。一方面，因为一路走来，遇到过很多很有想法的人，很有意思的人，他们的个性、态度绝不是一天两天就得到的，所以现在反而认为，淘气点也是个很好的优点。另一方面，从大学到步入社会以来，他们的想法和语言能力能让他们在社会和学校中成为佼佼者。</p><p>现在我也在不断的尝试改变一些固有的思路，用另一种态度，思维去看待一些东西。增加多方面的可能性，寻求另一种突破。</p><p>不过说起来，我也是个乖孩子的受益者，从大学的四六级，到现在的工作。我知道如何去梳理知识，如何从一个问题中发现其本质，然后试图找到问题的解决办法。所以多多少少也是种优势。</p><h2 id="步入社会"><a href="#步入社会" class="headerlink" title="步入社会"></a>步入社会</h2><p>今年，毕业了。从学校搬出来以后，发现外面的物价好贵，房价好贵，周围再也没有熟悉的同学了。一段时间里总是觉得空荡荡的，感觉失去了什么，心疼。在公司里呆久了，经历了很多人的入职、离职，一开始也是觉得不舍，不习惯，怎么突然就走了呢？一时间有些惴惴不安，四面楚歌，还好都过来了。现在面对同事离职，仍旧有些惋惜，但是多多少少淡定了些，大概这就是成长吧。看淡些就好了，事情总会发生，只是时间问题。</p><p>最近在看一部电视剧（很少看电视剧，但是那部剧的确反映了社会中的很多问题。很实际，很贴切）。剧里最让我印象深刻的是：远大的理想是买房，伟大的理想是买房。<br>虽然是14年的剧(主人公还在用黑莓),但是这句话放到现在对我来说还是很实际的。<br>以前没有想过这些问题，在这个阶段，愈发觉得很现实。颜值高的确有用，有车有房，的确有话语权，没车没房没颜值，loser不是你是谁？：]</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>作为一名程序员，技术浪潮滚滚向前，学习一直是第一生产力。比较开心的是，公司里的老猴子们都比较友善，大家都愿意教授自己的知识，这也是我比较看重的一点，融洽的气氛又有公司支持学习。希望今后的一段时间里能得到长足的进步，从各个方面提升自己的专业度。加油！！！</p><p>（互联网最大的特点就是消息发布的范围广，速度快。其说到这里不得不说一下马云，我对马云这人不是很了解，但是在他的一些演讲里，我觉得，其实马云的创业初期和大家都是一样的，都是什么赚钱就去做什么。唯一异于常人的一点就是马云当时学会了英语，然后看东西的角度和范围就不一样了，从一次次的创业失败中汲取教训，然后发现了一个商机并不断坚守，ok，他成功了。我认为他的成功很大程度上是依赖于互联网，他很想法，在互联网不是十分普及的时候就开始做。第一个吃螃蟹的人，首先占领了高地）</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>之前看到百度的一张搜索统计分析，发现的我搜素生活资料的次数接近于0，搜索技术问题的次数却很多。说实话，我认识到自己的缺陷，但是情商这种东西不是说要有就能有的，再加上平时最多的接触的还是代码，0或1的抉择十分明确。若有若无的东西是什么鬼？？<br>一定是BUG！很多时候真的觉得还是做个敲代码的小猴子就好，简简单单，买衣服花那么多时间还不如让我多学点技术问题，浪费时间。真想有个人能帮我选好衣服，我直接把钱转你好吗？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>技术展望</p><pre><code>新的一年希望能掌握的技术栈：1.JS／Node.js :目前也在学，对我来说新的东西嘛，到手的新东西总是比较的开心的，包括现在也有时间去学。个人认为，技术前景也不错。2.Swift:作为一名iOS开发居然还不怎么会用Swift简直说不过去3.Java: Java可以作为了解，慢慢深入。毕竟是比较大的一块东西。学起来也会是个缓慢的过程希望年底的时候再来看这个，能问心无愧的对自己说：都实现了！加油！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年发生了很多事，原本打算这次的年度总结会在星巴克里写，暖暖的空气，喝杯咖啡，望望窗外赶路的行人。计划往往赶不上变化。。。&lt;/p&gt;
&lt;h2 id=&quot;学生时代&quot;&gt;&lt;a href=&quot;#学生时代&quot; class=&quot;headerlink&quot; title=&quot;学生时代&quot;&gt;&lt;/a&gt;学生时代&lt;/h2&gt;&lt;p&gt;今年，完成了学校到社会的变迁，失去很多，收获的也很多，但无论怎样都是生命长河中的一部分。被时间赶着走，只能默默接受，习惯。现在的我还时常想起学生时代的样子，想想学生时代就这样结束了，总感觉空空的，我做了什么？？？&lt;/p&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>波浪效果实现</title>
    <link href="http://deeer.github.io/2016/03/17/%E6%B3%A2%E6%B5%AA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://deeer.github.io/2016/03/17/波浪效果实现/</id>
    <published>2016-03-17T14:45:53.000Z</published>
    <updated>2018-03-03T12:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中想添加一些动画，然后就想到了波浪的效果。<br>Google了一下大致，大致的方法就是用Quartz这个frameWork绘制</p><p>主要的核心代码<br><a id="more"></a></p><pre><code>-(void)drawRect:(CGRect)rect {  CGContextRef context = UIGraphicsGetCurrentContext();  CGMutablePathRef path = CGPathCreateMutable();  CGContextSetLineWidth(context, 1);  CGContextSetFillColorWithColor(context, [[UIColor purpleColor] CGColor]);  float y = basic_height;  CGPathMoveToPoint(path, NULL, 0, y);  //y = Asin(Bx+C)+D  //A：振幅 B：频率 C：左右偏移 D：相位for (float x= 0; x &lt;= rect.size.width; x++){     y = self.basicWaveNumber * sin(x/180.0*M_PI + 4 *self.RandonWaveNumber/M_PI) *5 +basic_height;  CGPathAddLineToPoint(path, nil, x, y);}  CGPathAddLineToPoint(path, nil, rect.size.width, rect.size.height);  CGPathAddLineToPoint(path, nil, 0, rect.size.height);  CGPathAddLineToPoint(path, nil, 0, basic_height);  CGContextAddPath(context, path);  CGContextFillPath(context);  CGContextDrawPath(context, kCGPathStroke);  CGPathRelease(path);}</code></pre><p>代码很简单，基本的思想上就是获取上下文，然后在每个像素上逐点描绘出波浪的形状，然后把各个点连起来。最后就是用定时器去每秒的刷新。</p><p>这里最为重要的一点就是在for循环中的“y = …” 这个公式。一开始简直就是一脸懵逼。然后慢慢挖掘，这居然是物理中的余弦公式（正弦公式也是一样的）。好吧，基本上已经还给老师了。高中以后那么多年。。哎</p><p>这里着重讲一下这个公式</p><blockquote><p>Y ＝ Asin(Bx + C)</p></blockquote><p>A: 振幅</p><p>B: 和频率相关,就是波动的快慢</p><p>C: 物理上讲叫相位，通俗的讲就是左右移动</p><p>基本上就是这样，我们要制作带有波动性的效果时，只要让B与C的值即可。</p><p><strong>但是</strong></p><p>总觉得这种方式的并不是最好的，0.02秒刷新一次，每次刷新还要执行一遍for循环。</p><p>so 尝试使用UIBezierPath与CALayer绘制，发现一个问题：之前使用贝塞尔绘制的曲线时都是一次，最多两次弯曲的曲线。像现在这这样多次连续弯曲的效果，一直没有遇到过。尝试使用- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;这个方法进行多个曲线的连续绘制，但是会在连接处出现不够平滑的现象，也就是说进行绘制的时候前一段的EndPoint与后一段startPoint没有任何连接性处理，所以出来的效果不能达到理想的平滑性</p><p>这个问题暂时没有解决，mark之。。。。<br>//TODO: to be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中想添加一些动画，然后就想到了波浪的效果。&lt;br&gt;Google了一下大致，大致的方法就是用Quartz这个frameWork绘制&lt;/p&gt;
&lt;p&gt;主要的核心代码&lt;br&gt;
    
    </summary>
    
      <category term="Animation" scheme="http://deeer.github.io/categories/Animation/"/>
    
    
      <category term="UIGraphics" scheme="http://deeer.github.io/tags/UIGraphics/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记之仿推特启动界面实现Demo</title>
    <link href="http://deeer.github.io/2016/01/03/%E4%BB%BF%E6%8E%A8%E7%89%B9%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0Demo/"/>
    <id>http://deeer.github.io/2016/01/03/仿推特启动界面实现Demo/</id>
    <published>2016-01-03T11:34:26.000Z</published>
    <updated>2018-03-03T12:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>前言</em></strong></p><p>今天要实现的是推特的启动界面的效果</p><p>类似于这样<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/twitterp.gif" alt="twitter0"><br><a id="more"></a></p><p>##首先<br>添加背景图片，之后在上面添加一层Layer作为遮罩。<br>这里的遮罩和PS中的遮罩效果大致相同。就是在上层layer的相应区域内才会出现下层区域的内容<br>效果如图<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/twittertwitter0.png" alt="twitter1"></p><p>很明显可以看出上层覆盖了一层星型的遮罩。</p><p>##第二步<br>实现遮罩的大小变化。<br>这里是使用CAKeyframeAnimtion 来实现<br>具体代码如下</p><pre><code>let transform = CAKeyframeAnimation(keyPath: &quot;bounds&quot;)    transform.delegate = self    transform.duration = 1    transform.beginTime = CACurrentMediaTime() + 1    let initalBounds = NSValue(CGRect:  CGRectMake(0, 0, 414, 763))    let secoundBounds = NSValue(CGRect: CGRectMake(0, 0, 50, 50))    let finalBounds = NSValue(CGRect:  CGRectMake(0, 0, 2000, 2000))    transform.values = [initalBounds,secoundBounds,finalBounds]    transform.keyTimes = [0 ,0.4,1]    transform.timingFunctions = [CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut),CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)]    transform.removedOnCompletion = false    transform.fillMode = kCAFillModeForwards    masklayer.addAnimation(transform, forKey:&quot;maskAnimation&quot;)    UIView.animateWithDuration(0.25, delay: 1.3, options: UIViewAnimationOptions.TransitionNone, animations: { () -&gt; Void in        self.backgroundImageView!.transform = CGAffineTransformMakeScale(1.05, 1.05)        }) { (NilLiteralConvertible) -&gt; Void in       }</code></pre><p><strong><em>－－－插播－－－</em></strong></p><ol><li>CAKeyframeAnimtion 从名字中也能看出是就是<em>关键帧动画</em>的意思。这个概念和flash中的关键帧动物十分相似。我们在使用flash制作相关动画的时候，常常需要设置初始状态，结束状态，然后使用补间动画完成过渡。我们甚至能在动画运动的过程中指定任意位置的状态。在这的实现也是同样的，我们通过keyPath可以创建对应的动画类型。<em>注意:</em>这里的’bounds’并不是随意给出的。有关key对应的可选值有:bounds、position等类似这样的Animatable属性。我们设置了三种状态initalBounds、secoundBounds、finalBounds分别对应三个keyTime:[0 ,0.4,1]</li></ol><p>2.当在给一个CALyer添加动画的时候，动画并没有改变layer的实际属性，系统会创建一个原始layer的拷贝作为并在此基础上进行动画渲染。苹果将原始layer称为Model Layer，将拷贝的layer称为Presentation Layer.Presentation Layer会随动画的进度实时改变，而Model Layer不会</p><p>3.在动画结束后，系统会自动销毁Presentation Layer所以动画会回到初始的状态，所以这里要使用removedOnCompletion这个属性，而这个属性默认是true，所以我们将其设为false。这样就不会移除最后的效果了</p><p>4.有关的fillMode的相关介绍:该属性有四个枚举值，分别对应四种不同的情况</p><pre><code>kCAFillModeRemoved:动画结束后，将layer设置回初始的状态,动画开始和结束前对动画都没有影响kCAFillModeForwards:动画结束后保持动画最后的状态kCAFillModeBackwards:动画开始前，只要将动画加入layer，layer就处于动画的初始状态kCAFillModeBoth:动画加入后，立即处于初始状态，动画结束后，保持动画结束状态</code></pre><p><strong><em>－－－插播结束－－－</em></strong></p><p>#最后<br>为了能将动画效果衔接的更好，我们需要在遮罩和背景层之间添加一层动画</p><pre><code>let maskView = UIView()   maskView.frame = CGRectMake(0, 0, 414, 867)   maskView.backgroundColor = UIColor.whiteColor()   self.view.addSubview(maskView)   self.view.bringSubviewToFront(maskView)   UIView .animateWithDuration(0.1, delay: 1.35, options: UIViewAnimationOptions.CurveEaseIn, animations: { () -&gt; Void in       maskView.alpha = 0.0       }) { (NilLiteralConvertible) -&gt; Void in           maskView.removeFromSuperview()   }</code></pre><p><strong><em>实现完整代码:<a href="https://github.com/Deeer/twitterLunchrAnnimationDemo" target="_blank" rel="noopener">https://github.com/Deeer/twitterLunchrAnnimationDemo</a></em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天要实现的是推特的启动界面的效果&lt;/p&gt;
&lt;p&gt;类似于这样&lt;br&gt;&lt;img src=&quot;http://7xjg07.com1.z0.glb.clouddn.com/twitterp.gif&quot; alt=&quot;twitter0&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOSDemo" scheme="http://deeer.github.io/categories/iOSDemo/"/>
    
    
      <category term="Twitter　" scheme="http://deeer.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>2015年度总结</title>
    <link href="http://deeer.github.io/2015/12/31/2015%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://deeer.github.io/2015/12/31/2015年度总结/</id>
    <published>2015-12-31T14:45:53.000Z</published>
    <updated>2018-02-27T15:18:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时光飞逝"><a href="#时光飞逝" class="headerlink" title="时光飞逝"></a>时光飞逝</h1><p>－－－记得上个年末时节，还在打算着用一年的时间来做一件事。但是一直想不到去做些什么。但是想不到后来会忙成这样。大四的上半学期，也就是15年的年末，开始走出校园，走向社会开始工作。又是一个新的开始的，新的起点，新的环境。在我投身工作的几个月里，时间真的非常快。每天都会有问题，每天都在想着尝试着解决问题。每天的最不爽的就是早上上班时候，说实话，睡眠时间真不够，有时甚至为了赶进度一天要工作近21个小时。3个小时的睡眠时间是个奢侈的享受。没办法，第二天还要工作，还是稍微会睡儿。在公交上也容易睡着，迷迷糊糊到公司，结果我还是第一个到的。公司离学校也不远，但是强迫症总觉得迟到不好，也许是在校时培养的习惯吧。所以一半都会提前半个小时到公司，只可惜电脑反应实在太慢，开机要好久。。。心好累😂。现在还只是一只小猴子，也算是初步走上了自己预想的轨迹吧。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>－－－大学生涯也就快过去了。从大一时陌生尴尬，到大四的“劳燕分飞”，整个过程是十分微妙的。感觉我的大学都没做什么就过去了，好快！！日子一天天的过，想想也有三年多了呢。现在是最后的尾巴了，所有过去发生的种种现在感觉都已经无所谓了。大家都是同学一场，也不容易。</p><p>突然发现整个似乎大学都是从“大家同学一场”开始，又是从“大家同学一场”结束的。也不用刻意追去什么，大家各自安好，才是真的好</p><hr><p>－－－新的一年，新的开始，今年的主题是REVERSE。希望能在接下来一年的时间里做些颠覆性的东西，尝试下不一样的选择。改变现在的生活状况，思维方式，让生活变的更加多彩！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时光飞逝&quot;&gt;&lt;a href=&quot;#时光飞逝&quot; class=&quot;headerlink&quot; title=&quot;时光飞逝&quot;&gt;&lt;/a&gt;时光飞逝&lt;/h1&gt;&lt;p&gt;－－－记得上个年末时节，还在打算着用一年的时间来做一件事。但是一直想不到去做些什么。但是想不到后来会忙成这样。大四的上半学期，也就是15年的年末，开始走出校园，走向社会开始工作。又是一个新的开始的，新的起点，新的环境。在我投身工作的几个月里，时间真的非常快。每天都会有问题，每天都在想着尝试着解决问题。每天的最不爽的就是早上上班时候，说实话，睡眠时间真不够，有时甚至为了赶进度一天要工作近21个小时。3个小时的睡眠时间是个奢侈的享受。没办法，第二天还要工作，还是稍微会睡儿。在公交上也容易睡着，迷迷糊糊到公司，结果我还是第一个到的。公司离学校也不远，但是强迫症总觉得迟到不好，也许是在校时培养的习惯吧。所以一半都会提前半个小时到公司，只可惜电脑反应实在太慢，开机要好久。。。心好累😂。现在还只是一只小猴子，也算是初步走上了自己预想的轨迹吧。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="年度总结" scheme="http://deeer.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://deeer.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UITableViewCell自适应高度（iOS8）</title>
    <link href="http://deeer.github.io/2015/09/27/UITableViewCell%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6Demo/"/>
    <id>http://deeer.github.io/2015/09/27/UITableViewCell自适应高度Demo/</id>
    <published>2015-09-27T05:55:05.000Z</published>
    <updated>2018-03-03T12:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目时遇到个cell的高度自适应问题,大致的需求是这样子的<br><br></p><p><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeIMG_0006.jpg" alt="Cell自适应"></p><p>cell中主要有三块区域分别对应三个label。并且三个label的y值是相同的。每个label之间的文字都有一定的距离，使得每块区域都有一个很好的划分。</p><a id="more"></a><p><br></p><p>#iOS8－－self Sizing Cells</p><p>开始没找到好的解决办法。字数一多也会出现一些问题。<br>今天特地好好整理了一下</p><p>发现在iOS8以后计算高度可以使用self Sizing Cells来对高度进行处理。<br>但是我们需要注意的:<br><br></p><p>1.cell重点内容必须有相应的约束－－网上看到一些使用Auto Layout来进行约束的。我这里是使用Masonry<br><br></p><p>2.设置tableview的estimatedRowHeight，或者设置cell的estimatedRowHeight高度。两者中任选其一即可，但是千万不能没有<br><br></p><p>3.设置tabelVeiw的rowHeight属性为UITableViewAutomaticDimension。<br><br></p><p>即在viewDidload中添加</p><pre><code>//cell用Masonry布局好后，添加这两句即可self.tableView.estimatedRowHeight = 44.0f;self.tableView.rowHeight = UITableViewAutomaticDimension;</code></pre><p>实现以上三步，我们就不用去处理与高度相相关的代理方法了</p><p>#注意</p><p>我们在用masonry进行自动布局的时候，如果cell中各个label文字没有对齐。即这种效果<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午2.42.30.png" alt="Cell自适应wrong2"></p><p>这里就是Masonry布局的问题了<br>下面我们为detailLbl添加bottom的offset值。</p><pre><code>- (void)createFrame {[self.nameLbl mas_makeConstraints:^(MASConstraintMaker *make) {make.left.equalTo(self.contentView).offset(15);make.top.equalTo(self.contentView).offset(15);make.width.lessThanOrEqualTo(@60);}];[self.detailLbl mas_makeConstraints:^(MASConstraintMaker *make) {   make.left.equalTo(self.contentView).offset(90);make.top.equalTo(self.contentView).offset(15);make.right.equalTo(self.contentView).offset(-65);//添加这句make.bottom.equalTo(self.contentView).offset(-10);}];[self.timeLbl mas_makeConstraints:^(MASConstraintMaker *make) {make.right.equalTo(self.contentView).offset(-15);make.top.equalTo(self.contentView).offset(15);make.width.lessThanOrEqualTo(@50);}];}</code></pre><p>这样无论文字多少，中间的文字适中距离底部都为10</p><p><br><br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午3.11.26.png" alt="CellFinal1"><br><br></p><p>效果不错的样子呢！！(^O^)<br>但是代码中暴露出又一个问题，左侧nameLbl文字一对会又会出现bug<br>什么鬼！！<br>于是又一次陷入了沉思中。。。<br><br><br><img src="http://7xjg07.com1.z0.glb.clouddn.com/Deedee.jpg" alt="InsertCPic"><br><br></p><p>翻翻文档又想出了一个好办法 －－不绑定bottom的边距，改为height设定最大值</p><pre><code>- (void)createFrame{    [self.nameLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.contentView).offset(15);    make.top.equalTo(self.contentView).offset(15);    make.width.lessThanOrEqualTo(@60);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];    [self.detailLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.left.equalTo(self.contentView).offset(90);    make.top.equalTo(self.contentView).offset(15);    make.right.equalTo(self.contentView).offset(-65);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];    [self.timeLbl mas_makeConstraints:^(MASConstraintMaker *make) {    make.right.equalTo(self.contentView).offset(-15);    make.top.equalTo(self.contentView).offset(15);    make.width.lessThanOrEqualTo(@50);    make.height.lessThanOrEqualTo(self.contentView.mas_height).offset(- 20);    }];}</code></pre><p>这样这样才是我们需要的最终结果呢！！^_^<br>哪怕字再多也不是问题了<br>如图<br><img src="http://7xjg07.com1.z0.glb.clouddn.com/DeeSimulator%20Screen%20Shot%202015年9月27日%20下午3.27.37.png" alt="cellFinal"><br>好吧。。图是有点丑，但是这样才是比较极端的情况<br><br></p><p>如果有什么不对，或者有更好的解决方法，还望指出，万分感谢😀<br>以下是完整项目链接<a href="https://github.com/Deeer/DeeLearning" target="_blank" rel="noopener">https://github.com/Deeer/DeeLearning</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做项目时遇到个cell的高度自适应问题,大致的需求是这样子的&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xjg07.com1.z0.glb.clouddn.com/DeeIMG_0006.jpg&quot; alt=&quot;Cell自适应&quot;&gt;&lt;/p&gt;
&lt;p&gt;cell中主要有三块区域分别对应三个label。并且三个label的y值是相同的。每个label之间的文字都有一定的距离，使得每块区域都有一个很好的划分。&lt;/p&gt;
    
    </summary>
    
      <category term="iOSDemo" scheme="http://deeer.github.io/categories/iOSDemo/"/>
    
    
      <category term="UITabelViewCell" scheme="http://deeer.github.io/tags/UITabelViewCell/"/>
    
  </entry>
  
  <entry>
    <title>new</title>
    <link href="http://deeer.github.io/2015/06/01/new/"/>
    <id>http://deeer.github.io/2015/06/01/new/</id>
    <published>2015-05-31T18:26:59.000Z</published>
    <updated>2018-02-27T14:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>记于：2015年6月1日凌晨2：30. 自己做的第一个博客，六一快乐！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记于：2015年6月1日凌晨2：30. 自己做的第一个博客，六一快乐！！！&lt;/p&gt;

      
    
    </summary>
    
      <category term="LIFE" scheme="http://deeer.github.io/categories/LIFE/"/>
    
    
      <category term="LIFE" scheme="http://deeer.github.io/tags/LIFE/"/>
    
  </entry>
  
</feed>
